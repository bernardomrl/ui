{"version":3,"file":"index.cjs88.js","sources":["../node_modules/react-resizable-panels/dist/react-resizable-panels.browser.js"],"sourcesContent":["import * as React from 'react';\nimport { createContext, useLayoutEffect, useRef, forwardRef, createElement, useContext, useImperativeHandle, useState, useCallback, useEffect, useMemo } from 'react';\n\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst DATA_ATTRIBUTES = {\n  group: \"data-panel-group\",\n  groupDirection: \"data-panel-group-direction\",\n  groupId: \"data-panel-group-id\",\n  panel: \"data-panel\",\n  panelCollapsible: \"data-panel-collapsible\",\n  panelId: \"data-panel-id\",\n  panelSize: \"data-panel-size\",\n  resizeHandle: \"data-resize-handle\",\n  resizeHandleActive: \"data-resize-handle-active\",\n  resizeHandleEnabled: \"data-panel-resize-handle-enabled\",\n  resizeHandleId: \"data-panel-resize-handle-id\",\n  resizeHandleState: \"data-resize-handle-state\"\n};\nconst PRECISION = 10;\n\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\n\nconst useId = React[\"useId\".toString()];\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    const prevConstraints = {\n      ...constraints\n    };\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSize = collapsedSize;\n    constraints.collapsible = collapsible;\n    constraints.defaultSize = defaultSize;\n    constraints.maxSize = maxSize;\n    constraints.minSize = minSize;\n\n    // If constraints have changed, we should revisit panel sizes.\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\n    }\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: minSize => {\n      expandPanel(panelDataRef.current, minSize);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: panelId,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.panel]: \"\",\n    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || undefined,\n    [DATA_ATTRIBUTES.panelId]: panelId,\n    [DATA_ATTRIBUTES.panelSize]: parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nlet nonce;\nfunction getNonce() {\n  return nonce;\n}\nfunction setNonce(value) {\n  nonce = value;\n}\n\nlet currentCursorStyle = null;\nlet enabled = true;\nlet getCustomCursorStyleFunction = null;\nlet prevRuleIndex = -1;\nlet styleElement = null;\nfunction customizeGlobalCursorStyles(callback) {\n  getCustomCursorStyleFunction = callback;\n}\nfunction disableGlobalCursorStyles() {\n  enabled = false;\n}\nfunction enableGlobalCursorStyles() {\n  enabled = true;\n}\nfunction getCursorStyle(state, constraintFlags, isPointerDown) {\n  const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n  const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n  const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n  const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n  if (getCustomCursorStyleFunction) {\n    return getCustomCursorStyleFunction({\n      exceedsHorizontalMaximum: horizontalMax,\n      exceedsHorizontalMinimum: horizontalMin,\n      exceedsVerticalMaximum: verticalMax,\n      exceedsVerticalMinimum: verticalMin,\n      intersectsHorizontalDragHandle: state === \"horizontal\" || state === \"intersection\",\n      intersectsVerticalDragHandle: state === \"vertical\" || state === \"intersection\",\n      isPointerDown\n    });\n  }\n  if (constraintFlags) {\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n    prevRuleIndex = -1;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags, isPointerDown) {\n  var _styleElement$sheet$i, _styleElement$sheet2;\n  if (!enabled) {\n    return;\n  }\n  const style = getCursorStyle(state, constraintFlags, isPointerDown);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    const nonce = getNonce();\n    if (nonce) {\n      styleElement.setAttribute(\"nonce\", nonce);\n    }\n    document.head.appendChild(styleElement);\n  }\n  if (prevRuleIndex >= 0) {\n    var _styleElement$sheet;\n    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);\n  }\n  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isPointerEvent(event) {\n  return event.type.startsWith(\"pointer\");\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\n\nfunction getResizeEventCoordinates(event) {\n  if (isPointerEvent(event)) {\n    if (event.isPrimary) {\n      return {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n  } else if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\n\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\n\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement | SVGElement} a\n * @param {HTMLElement | SVGElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement | SVGElement} node */\nfunction is_flex_item(node) {\n  var _get_parent;\n  // @ts-ignore\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {(HTMLElement| SVGElement)[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    // @ts-ignore\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  const {\n    parentNode\n  } = node;\n  if (parentNode && parentNode instanceof ShadowRoot) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n\n    // If the resize handle that is currently unmounting is intersecting with the pointer,\n    // update the global pointer to account for the change\n    if (intersectingHandles.includes(data)) {\n      const index = intersectingHandles.indexOf(data);\n      if (index >= 0) {\n        intersectingHandles.splice(index, 1);\n      }\n      updateCursor();\n\n      // Also instruct the handle to stop dragging; this prevents the parent group from being left in an inconsistent state\n      // See github.com/bvaughn/react-resizable-panels/issues/402\n      setResizeHandlerState(\"up\", true, null);\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n\n    // Update cursor based on return value(s) from active handles\n    updateCursor();\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n\n  // Edge case (see #340)\n  // Detect when the pointer has been released outside an iframe on a different domain\n  if (isPointerDown &&\n  // Skip this check for \"pointerleave\" events, else Firefox triggers a false positive (see #514)\n  event.type !== \"pointerleave\" && event.buttons === 0) {\n    isPointerDown = false;\n    updateResizeHandlerStates(\"up\", event);\n  }\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction isWithinResizeHandle(element) {\n  let currentElement = element;\n  while (currentElement) {\n    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {\n      return true;\n    }\n    currentElement = currentElement.parentElement;\n  }\n  return false;\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement || target instanceof SVGElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags, isPointerDown);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags, isPointerDown);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags, isPointerDown);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nlet listenersAbortController;\nfunction updateListeners() {\n  var _listenersAbortContro;\n  (_listenersAbortContro = listenersAbortController) === null || _listenersAbortContro === void 0 ? void 0 : _listenersAbortContro.abort();\n  listenersAbortController = new AbortController();\n  const options = {\n    capture: true,\n    signal: listenersAbortController.signal\n  };\n  if (!registeredResizeHandlers.size) {\n    return;\n  }\n  if (isPointerDown) {\n    if (intersectingHandles.length > 0) {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"contextmenu\", handlePointerUp, options);\n          body.addEventListener(\"pointerleave\", handlePointerMove, options);\n          body.addEventListener(\"pointermove\", handlePointerMove, options);\n        }\n      });\n    }\n    ownerDocumentCounts.forEach((_, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      body.addEventListener(\"pointerup\", handlePointerUp, options);\n      body.addEventListener(\"pointercancel\", handlePointerUp, options);\n    });\n  } else {\n    ownerDocumentCounts.forEach((count, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      if (count > 0) {\n        body.addEventListener(\"pointerdown\", handlePointerDown, options);\n        body.addEventListener(\"pointermove\", handlePointerMove, options);\n      }\n    });\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\n\nfunction useForceUpdate() {\n  const [_, setCount] = useState(0);\n  return useCallback(() => setCount(prevCount => prevCount + 1), []);\n}\n\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too–\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toFixed(3).localeCompare(Math.abs(delta).toFixed(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\n\nfunction calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  assert(firstIndex != null, \"No pivot index found\");\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = constraints;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction isHTMLElement(target) {\n  if (target instanceof HTMLElement) {\n    return true;\n  }\n\n  // Fallback to duck typing to handle edge case of portals within a popup window\n  return typeof target === \"object\" && target !== null && \"tagName\" in target && \"getAttribute\" in target;\n}\n\nfunction getPanelGroupElement(id, rootElement = document) {\n  // If the root element is the PanelGroup\n  if (isHTMLElement(rootElement) && rootElement.dataset.panelGroupId == id) {\n    return rootElement;\n  }\n\n  // Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) ; else {\n        const panelData = panelDataArray[index];\n        assert(panelData, `No panel data found for index \"${index}\"`);\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\n\nfunction calculateUnsafeDefaultLayout({\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toFixed(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toFixed(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\n  var _loadSerializedPanelG, _state$panelKey;\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\n  const panelKey = getPanelKey(panels);\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const forceUpdate = useForceUpdate();\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback((panelData, minSizeOverride) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize = 0,\n        minSize: minSizeFromProps = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n    forceUpdate();\n  }, [forceUpdate]);\n\n  // (Re)calculate group layout whenever panels are registered or unregistered.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsomorphicLayoutEffect(() => {\n    if (eagerValuesRef.current.panelDataArrayChanged) {\n      eagerValuesRef.current.panelDataArrayChanged = false;\n      const {\n        autoSaveId,\n        onLayout,\n        storage\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n\n      // If this panel has been configured to persist sizing information,\n      // default size should be restored from local storage if possible.\n      let unsafeLayout = null;\n      if (autoSaveId) {\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\n        if (state) {\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\n          unsafeLayout = state.layout;\n        }\n      }\n      if (unsafeLayout == null) {\n        unsafeLayout = calculateUnsafeDefaultLayout({\n          panelDataArray\n        });\n      }\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  });\n\n  // Reset the cached layout if hidden by the Activity/Offscreen API\n  useIsomorphicLayoutEffect(() => {\n    const eagerValues = eagerValuesRef.current;\n    return () => {\n      eagerValues.layout = [];\n    };\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    let isRTL = false;\n    const panelGroupElement = panelGroupElementRef.current;\n    if (panelGroupElement) {\n      const style = window.getComputedStyle(panelGroupElement, null);\n      if (style.getPropertyValue(\"direction\") === \"rtl\") {\n        isRTL = true;\n      }\n    }\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n      const isHorizontal = direction === \"horizontal\";\n      if (isHorizontal && isRTL) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isPointerEvent(event) || isMouseEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged && delta !== 0) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n\n  // TODO Multiple drag handles can be active at the same time so this API is a bit awkward now\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n      forceUpdate();\n    }\n  }, [forceUpdate]);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.group]: \"\",\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onBlur,\n  onClick,\n  onDragging,\n  onFocus,\n  onPointerDown,\n  onPointerUp,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  var _hitAreaMargins$coars, _hitAreaMargins$fine;\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onClick,\n    onDragging,\n    onPointerDown,\n    onPointerUp\n  });\n  useEffect(() => {\n    callbacksRef.current.onClick = onClick;\n    callbacksRef.current.onDragging = onDragging;\n    callbacksRef.current.onPointerDown = onPointerDown;\n    callbacksRef.current.onPointerUp = onPointerUp;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.state = state;\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n\n  // Extract hit area margins before passing them to the effect's dependency array\n  // so that inline object values won't trigger re-renders\n  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\n  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    let didMove = false;\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (!isActive) {\n        setState(\"inactive\");\n        return;\n      }\n      switch (action) {\n        case \"down\":\n          {\n            setState(\"drag\");\n            didMove = false;\n            assert(event, 'Expected event to be defined for \"down\" action');\n            startDragging(resizeHandleId, event);\n            const {\n              onDragging,\n              onPointerDown\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(true);\n            onPointerDown === null || onPointerDown === void 0 ? void 0 : onPointerDown();\n            break;\n          }\n        case \"move\":\n          {\n            const {\n              state\n            } = committedValuesRef.current;\n            didMove = true;\n            if (state !== \"drag\") {\n              setState(\"hover\");\n            }\n            assert(event, 'Expected event to be defined for \"move\" action');\n            resizeHandler(event);\n            break;\n          }\n        case \"up\":\n          {\n            setState(\"hover\");\n            stopDragging();\n            const {\n              onClick,\n              onDragging,\n              onPointerUp\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(false);\n            onPointerUp === null || onPointerUp === void 0 ? void 0 : onPointerUp();\n            if (!didMove) {\n              onClick === null || onClick === void 0 ? void 0 : onClick();\n            }\n            break;\n          }\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      coarse: coarseHitAreaMargins,\n      fine: fineHitAreaMargins\n    }, setResizeHandlerState);\n  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => {\n      setIsFocused(false);\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur();\n    },\n    onFocus: () => {\n      setIsFocused(true);\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus();\n    },\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.resizeHandle]: \"\",\n    [DATA_ATTRIBUTES.resizeHandleActive]: state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,\n    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,\n    [DATA_ATTRIBUTES.resizeHandleState]: state\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nfunction usePanelGroupContext() {\n  const context = useContext(PanelGroupContext);\n  return {\n    direction: context === null || context === void 0 ? void 0 : context.direction,\n    groupId: context === null || context === void 0 ? void 0 : context.groupId\n  };\n}\n\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\n\nexport { DATA_ATTRIBUTES, Panel, PanelGroup, PanelResizeHandle, assert, customizeGlobalCursorStyles, disableGlobalCursorStyles, enableGlobalCursorStyles, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects, setNonce, usePanelGroupContext };\n"],"names":["PanelGroupContext","createContext","DATA_ATTRIBUTES","PRECISION","useIsomorphicLayoutEffect","useLayoutEffect","useId","React","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","useRef","PanelWithForwardedRef","children","classNameFromProps","collapsedSize","collapsible","defaultSize","forwardedRef","idFromProps","maxSize","minSize","onCollapse","onExpand","onResize","order","styleFromProps","Type","rest","context","useContext","collapsePanel","expandPanel","getPanelSize","getPanelStyle","groupId","isPanelCollapsed","reevaluatePanelConstraints","registerPanel","resizePanel","unregisterPanel","panelId","panelDataRef","callbacks","constraints","prevConstraints","panelData","useImperativeHandle","size","style","createElement","Panel","forwardRef","props","ref","currentCursorStyle","prevRuleIndex","styleElement","getCursorStyle","state","constraintFlags","isPointerDown","horizontalMin","EXCEEDED_HORIZONTAL_MIN","horizontalMax","EXCEEDED_HORIZONTAL_MAX","verticalMin","EXCEEDED_VERTICAL_MIN","verticalMax","EXCEEDED_VERTICAL_MAX","resetGlobalCursorStyle","setGlobalCursorStyle","_styleElement$sheet$i","_styleElement$sheet2","_styleElement$sheet","isKeyDown","event","isPointerEvent","isMouseEvent","getResizeEventCoordinates","getInputType","intersects","rectOne","rectTwo","strict","compare","a","b","ancestors","get_ancestors","common_ancestor","assert","z_indexes","get_z_index","find_stacking_context","furthest_ancestors","i","child","is_flex_item","node","_get_parent","display","get_parent","creates_stacking_context","nodes","parentNode","isCoarsePointer","intersectingHandles","ownerDocumentCounts","panelConstraintFlags","registeredResizeHandlers","registerResizeHandle","resizeHandleId","element","direction","hitAreaMargins","setResizeHandlerState","_ownerDocumentCounts$","ownerDocument","data","count","updateListeners","_ownerDocumentCounts$2","index","updateCursor","handlePointerDown","target","x","y","recalculateIntersectingHandles","updateResizeHandlerStates","isWithinResizeHandle","handlePointerMove","handlePointerUp","currentElement","targetElement","dragHandleElement","dragHandleRect","bottom","left","right","top","margin","didIntersect","reportConstraintsViolation","flag","intersectsHorizontal","intersectsVertical","listenersAbortController","_listenersAbortContro","options","body","_","action","isActive","useForceUpdate","setCount","useState","useCallback","prevCount","expectedCondition","message","fuzzyCompareNumbers","actual","expected","fractionDigits","fuzzyNumbersEqual$1","fuzzyNumbersEqual","fuzzyLayoutsEqual","actualSize","expectedSize","panelConstraintsArray","panelIndex","panelConstraints","halfwayPoint","adjustLayoutByDelta","delta","initialLayout","pivotIndices","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize","localDelta","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","unsafeSize","safeSize","pivotIndex","totalSize","total","calculateAriaValues","layout","panelsArray","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","valueMax","valueMin","valueNow","getResizeHandleElementsForGroup","scope","getResizeHandleElementIndex","id","handle","determinePivotIndices","dragHandleId","panelGroupElement","isHTMLElement","getPanelGroupElement","rootElement","getResizeHandleElement","getResizeHandlePanelIds","handleId","_panelsArray$index$id","_panelsArray$index","_panelsArray$id","_panelsArray","handles","idBefore","idAfter","useWindowSplitterPanelGroupBehavior","committedValuesRef","eagerValuesRef","panelDataArray","setLayout","resizeHandleElements","resizeHandleElement","useEffect","eagerValues","groupElement","cleanupFunctions","onKeyDown","cleanupFunction","areEqual","arrayA","arrayB","getResizeEventCursorPosition","isHorizontal","calculateDragOffsetPercentage","initialDragState","handleElement","initialCursorPosition","cursorPosition","groupRect","groupSizeInPixels","calculateDeltaPercentage","keyboardResizeBy","movement","calculateUnsafeDefaultLayout","numPanelsWithSizes","remainingSize","numRemainingPanels","callPanelCallbacks","panelIdToLastNotifiedSizeMap","lastNotifiedSize","compareLayouts","computePanelFlexBoxStyle","dragState","precision","flexGrow","debounce","callback","durationMs","timeoutId","args","initializeDefaultStorage","storageObject","name","value","error","getPanelGroupKey","autoSaveId","getPanelKey","panels","panel","idIsFromProps","loadSerializedPanelGroupState","storage","panelGroupKey","serialized","parsed","loadPanelGroupState","_loadSerializedPanelG","_state$panelKey","panelKey","savePanelGroupState","panelSizesBeforeCollapse","sizes","_loadSerializedPanelG2","validatePanelGroupLayout","nextLayoutTotalSize","accumulated","current","LOCAL_STORAGE_DEBOUNCE_INTERVAL","defaultStorage","debounceMap","PanelGroupWithForwardedRef","onLayout","panelGroupElementRef","setDragState","forceUpdate","panelIdToLastNotifiedSizeMapRef","panelSizeBeforeCollapseRef","prevDeltaRef","unsafeLayout","safeLayout","debouncedSave","clonedPanelDataArray","clonedPanelSizesBeforeCollapse","panelSize","panelDataHelper","findPanelDataIndex","minSizeOverride","minSizeFromProps","prevPanelSize","baseSize","isPanelExpanded","panelA","panelB","orderA","orderB","isRTL","layoutChanged","unsafePanelSize","prevCollapsedSize","prevCollapsible","nextCollapsedSize","nextCollapsible","nextMaxSize","nextMinSize","startDragging","stopDragging","useMemo","PanelGroup","prevPanelData","useWindowSplitterResizeHandlerBehavior","disabled","resizeHandler","nextIndex","PanelResizeHandle","onBlur","onClick","onDragging","onFocus","onPointerDown","onPointerUp","tabIndex","_hitAreaMargins$coars","_hitAreaMargins$fine","elementRef","callbacksRef","panelGroupContext","registerResizeHandleWithParentGroup","setState","isFocused","setIsFocused","setResizeHandler","coarseHitAreaMargins","fineHitAreaMargins","didMove"],"mappings":"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","x_google_ignoreList":[0]}