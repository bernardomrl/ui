{"version":3,"file":"index.cjs127.js","sources":["../node_modules/@radix-ui/react-focus-scope/dist/index.mjs"],"sourcesContent":["\"use client\";\n\n// src/focus-scope.tsx\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { jsx } from \"react/jsx-runtime\";\nvar AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nvar AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\";\nvar EVENT_OPTIONS = { bubbles: false, cancelable: true };\nvar FOCUS_SCOPE_NAME = \"FocusScope\";\nvar FocusScope = React.forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current;\n  React.useEffect(() => {\n    if (trapped) {\n      let handleFocusIn2 = function(event) {\n        if (focusScope.paused || !container) return;\n        const target = event.target;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }, handleFocusOut2 = function(event) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget;\n        if (relatedTarget === null) return;\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }, handleMutations2 = function(mutations) {\n        const focusedElement = document.activeElement;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      };\n      var handleFocusIn = handleFocusIn2, handleFocusOut = handleFocusOut2, handleMutations = handleMutations2;\n      document.addEventListener(\"focusin\", handleFocusIn2);\n      document.addEventListener(\"focusout\", handleFocusOut2);\n      const mutationObserver = new MutationObserver(handleMutations2);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n      return () => {\n        document.removeEventListener(\"focusin\", handleFocusIn2);\n        document.removeEventListener(\"focusout\", handleFocusOut2);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n  const handleKeyDown = React.useCallback(\n    (event) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n      const isTabKey = event.key === \"Tab\" && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement;\n      if (isTabKey && focusedElement) {\n        const container2 = event.currentTarget;\n        const [first, last] = getTabbableEdges(container2);\n        const hasTabbableElementsInside = first && last;\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container2) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n  return /* @__PURE__ */ jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });\n});\nFocusScope.displayName = FOCUS_SCOPE_NAME;\nfunction focusFirst(candidates, { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\nfunction getTabbableEdges(container) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last];\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node) => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction findVisible(elements, container) {\n  for (const element of elements) {\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\nfunction isHidden(node, { upTo }) {\n  if (getComputedStyle(node).visibility === \"hidden\") return true;\n  while (node) {\n    if (upTo !== void 0 && node === upTo) return false;\n    if (getComputedStyle(node).display === \"none\") return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction isSelectableInput(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n}\nfunction focus(element, { select = false } = {}) {\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    element.focus({ preventScroll: true });\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\nvar focusScopesStack = createFocusScopesStack();\nfunction createFocusScopesStack() {\n  let stack = [];\n  return {\n    add(focusScope) {\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    }\n  };\n}\nfunction arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\nfunction removeLinks(items) {\n  return items.filter((item) => item.tagName !== \"A\");\n}\nvar Root = FocusScope;\nexport {\n  FocusScope,\n  Root\n};\n//# sourceMappingURL=index.mjs.map\n"],"names":["AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_UNMOUNT","EVENT_OPTIONS","FOCUS_SCOPE_NAME","FocusScope","React","props","forwardedRef","loop","trapped","onMountAutoFocusProp","onUnmountAutoFocusProp","scopeProps","container","setContainer","onMountAutoFocus","useCallbackRef","onUnmountAutoFocus","lastFocusedElementRef","composedRefs","useComposedRefs","node","focusScope","handleFocusIn2","event","target","focus","handleFocusOut2","relatedTarget","handleMutations2","mutations","mutation","mutationObserver","focusScopesStack","previouslyFocusedElement","mountEvent","focusFirst","removeLinks","getTabbableCandidates","unmountEvent","handleKeyDown","isTabKey","focusedElement","container2","first","last","getTabbableEdges","jsx","Primitive","candidates","select","candidate","findVisible","nodes","walker","isHiddenInput","elements","element","isHidden","upTo","isSelectableInput","createFocusScopesStack","stack","activeFocusScope","arrayRemove","array","item","updatedArray","index","items"],"mappings":"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","x_google_ignoreList":[0]}