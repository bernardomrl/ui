"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m=require("react"),b=require("./index.cjs105.js");function v(e){const o=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const t in e)if(t!=="default"){const r=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(o,t,r.get?r:{enumerable:!0,get:()=>e[t]})}}return o.default=e,Object.freeze(o)}const n=v(m);var g=n[" useInsertionEffect ".trim().toString()]||b.useLayoutEffect;function R({prop:e,defaultProp:o,onChange:t=()=>{},caller:r}){const[s,l,i]=S({defaultProp:o,onChange:t}),c=e!==void 0,a=c?e:s;{const u=n.useRef(e!==void 0);n.useEffect(()=>{const f=u.current;f!==c&&console.warn(`${r} is changing from ${f?"controlled":"uncontrolled"} to ${c?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),u.current=c},[c,r])}const d=n.useCallback(u=>{if(c){const f=y(u)?u(e):u;f!==e&&i.current?.(f)}else l(u)},[c,e,l,i]);return[a,d]}function S({defaultProp:e,onChange:o}){const[t,r]=n.useState(e),s=n.useRef(t),l=n.useRef(o);return g(()=>{l.current=o},[o]),n.useEffect(()=>{s.current!==t&&(l.current?.(t),s.current=t)},[t,s]),[t,r,l]}function y(e){return typeof e=="function"}exports.useControllableState=R;
//# sourceMappingURL=index.cjs111.js.map
