{"version":3,"file":"index.es160.js","sources":["../node_modules/@date-fns/tz/date/mini.js"],"sourcesContent":["import { tzOffset } from \"../tzOffset/index.js\";\nexport class TZDateMini extends Date {\n  //#region static\n\n  constructor(...args) {\n    super();\n    if (args.length > 1 && typeof args[args.length - 1] === \"string\") {\n      this.timeZone = args.pop();\n    }\n    this.internal = new Date();\n    if (isNaN(tzOffset(this.timeZone, this))) {\n      this.setTime(NaN);\n    } else {\n      if (!args.length) {\n        this.setTime(Date.now());\n      } else if (typeof args[0] === \"number\" && (args.length === 1 || args.length === 2 && typeof args[1] !== \"number\")) {\n        this.setTime(args[0]);\n      } else if (typeof args[0] === \"string\") {\n        this.setTime(+new Date(args[0]));\n      } else if (args[0] instanceof Date) {\n        this.setTime(+args[0]);\n      } else {\n        this.setTime(+new Date(...args));\n        adjustToSystemTZ(this, NaN);\n        syncToInternal(this);\n      }\n    }\n  }\n  static tz(tz, ...args) {\n    return args.length ? new TZDateMini(...args, tz) : new TZDateMini(Date.now(), tz);\n  }\n\n  //#endregion\n\n  //#region time zone\n\n  withTimeZone(timeZone) {\n    return new TZDateMini(+this, timeZone);\n  }\n  getTimezoneOffset() {\n    const offset = -tzOffset(this.timeZone, this);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    return offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n  }\n\n  //#endregion\n\n  //#region time\n\n  setTime(time) {\n    Date.prototype.setTime.apply(this, arguments);\n    syncToInternal(this);\n    return +this;\n  }\n\n  //#endregion\n\n  //#region date-fns integration\n\n  [Symbol.for(\"constructDateFrom\")](date) {\n    return new TZDateMini(+new Date(date), this.timeZone);\n  }\n\n  //#endregion\n}\n\n// Assign getters and setters\nconst re = /^(get|set)(?!UTC)/;\nObject.getOwnPropertyNames(Date.prototype).forEach(method => {\n  if (!re.test(method)) return;\n  const utcMethod = method.replace(re, \"$1UTC\");\n  // Filter out methods without UTC counterparts\n  if (!TZDateMini.prototype[utcMethod]) return;\n  if (method.startsWith(\"get\")) {\n    // Delegate to internal date's UTC method\n    TZDateMini.prototype[method] = function () {\n      return this.internal[utcMethod]();\n    };\n  } else {\n    // Assign regular setter\n    TZDateMini.prototype[method] = function () {\n      Date.prototype[utcMethod].apply(this.internal, arguments);\n      syncFromInternal(this);\n      return +this;\n    };\n\n    // Assign UTC setter\n    TZDateMini.prototype[utcMethod] = function () {\n      Date.prototype[utcMethod].apply(this, arguments);\n      syncToInternal(this);\n      return +this;\n    };\n  }\n});\n\n/**\n * Function syncs time to internal date, applying the time zone offset.\n *\n * @param {Date} date - Date to sync\n */\nfunction syncToInternal(date) {\n  date.internal.setTime(+date);\n  date.internal.setUTCSeconds(date.internal.getUTCSeconds() - Math.round(-tzOffset(date.timeZone, date) * 60));\n}\n\n/**\n * Function syncs the internal date UTC values to the date. It allows to get\n * accurate timestamp value.\n *\n * @param {Date} date - The date to sync\n */\nfunction syncFromInternal(date) {\n  // First we transpose the internal values\n  Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());\n  Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());\n\n  // Now we have to adjust the date to the system time zone\n  adjustToSystemTZ(date);\n}\n\n/**\n * Function adjusts the date to the system time zone. It uses the time zone\n * differences to calculate the offset and adjust the date.\n *\n * @param {Date} date - Date to adjust\n */\nfunction adjustToSystemTZ(date) {\n  // Save the time zone offset before all the adjustments\n  const baseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const offset = baseOffset > 0 ? Math.floor(baseOffset) : Math.ceil(baseOffset);\n  //#region System DST adjustment\n\n  // The biggest problem with using the system time zone is that when we create\n  // a date from internal values stored in UTC, the system time zone might end\n  // up on the DST hour:\n  //\n  //   $ TZ=America/New_York node\n  //   > new Date(2020, 2, 8, 1).toString()\n  //   'Sun Mar 08 2020 01:00:00 GMT-0500 (Eastern Standard Time)'\n  //   > new Date(2020, 2, 8, 2).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 3).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 4).toString()\n  //   'Sun Mar 08 2020 04:00:00 GMT-0400 (Eastern Daylight Time)'\n  //\n  // Here we get the same hour for both 2 and 3, because the system time zone\n  // has DST beginning at 8 March 2020, 2 a.m. and jumps to 3 a.m. So we have\n  // to adjust the internal date to reflect that.\n  //\n  // However we want to adjust only if that's the DST hour the change happenes,\n  // not the hour where DST moves to.\n\n  // We calculate the previous hour to see if the time zone offset has changed\n  // and we have landed on the DST hour.\n  const prevHour = new Date(+date);\n  // We use UTC methods here as we don't want to land on the same hour again\n  // in case of DST.\n  prevHour.setUTCHours(prevHour.getUTCHours() - 1);\n\n  // Calculate if we are on the system DST hour.\n  const systemOffset = -new Date(+date).getTimezoneOffset();\n  const prevHourSystemOffset = -new Date(+prevHour).getTimezoneOffset();\n  const systemDSTChange = systemOffset - prevHourSystemOffset;\n  // Detect the DST shift. System DST change will occur both on\n  const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();\n\n  // Move the internal date when we are on the system DST hour.\n  if (systemDSTChange && dstShift) date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);\n\n  //#endregion\n\n  //#region System diff adjustment\n\n  // Now we need to adjust the date, since we just applied internal values.\n  // We need to calculate the difference between the system and date time zones\n  // and apply it to the date.\n\n  const offsetDiff = systemOffset - offset;\n  if (offsetDiff) Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);\n\n  //#endregion\n\n  //#region Seconds System diff adjustment\n\n  const systemDate = new Date(+date);\n  // Set the UTC seconds to 0 to isolate the timezone offset in seconds.\n  systemDate.setUTCSeconds(0);\n  // For negative systemOffset, invert the seconds.\n  const systemSecondsOffset = systemOffset > 0 ? systemDate.getSeconds() : (systemDate.getSeconds() - 60) % 60;\n\n  // Calculate the seconds offset based on the timezone offset.\n  const secondsOffset = Math.round(-(tzOffset(date.timeZone, date) * 60)) % 60;\n  if (secondsOffset || systemSecondsOffset) {\n    date.internal.setUTCSeconds(date.internal.getUTCSeconds() + secondsOffset);\n    Date.prototype.setUTCSeconds.call(date, Date.prototype.getUTCSeconds.call(date) + secondsOffset + systemSecondsOffset);\n  }\n\n  //#endregion\n\n  //#region Post-adjustment DST fix\n\n  const postBaseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const postOffset = postBaseOffset > 0 ? Math.floor(postBaseOffset) : Math.ceil(postBaseOffset);\n  const postSystemOffset = -new Date(+date).getTimezoneOffset();\n  const postOffsetDiff = postSystemOffset - postOffset;\n  const offsetChanged = postOffset !== offset;\n  const postDiff = postOffsetDiff - offsetDiff;\n  if (offsetChanged && postDiff) {\n    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);\n\n    // Now we need to check if got offset change during the post-adjustment.\n    // If so, we also need both dates to reflect that.\n\n    const newBaseOffset = tzOffset(date.timeZone, date);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    const newOffset = newBaseOffset > 0 ? Math.floor(newBaseOffset) : Math.ceil(newBaseOffset);\n    const offsetChange = postOffset - newOffset;\n    if (offsetChange) {\n      date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);\n      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);\n    }\n  }\n\n  //#endregion\n}"],"names":["TZDateMini","args","tzOffset","adjustToSystemTZ","syncToInternal","tz","timeZone","offset","time","date","re","method","utcMethod","syncFromInternal","baseOffset","prevHour","systemOffset","prevHourSystemOffset","systemDSTChange","dstShift","offsetDiff","systemDate","systemSecondsOffset","secondsOffset","postBaseOffset","postOffset","postOffsetDiff","offsetChanged","postDiff","newBaseOffset","newOffset","offsetChange"],"mappings":"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","x_google_ignoreList":[0]}