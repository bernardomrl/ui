{"version":3,"file":"index.es88.js","sources":["../node_modules/react-resizable-panels/dist/react-resizable-panels.browser.js"],"sourcesContent":["import * as React from 'react';\nimport { createContext, useLayoutEffect, useRef, forwardRef, createElement, useContext, useImperativeHandle, useState, useCallback, useEffect, useMemo } from 'react';\n\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst DATA_ATTRIBUTES = {\n  group: \"data-panel-group\",\n  groupDirection: \"data-panel-group-direction\",\n  groupId: \"data-panel-group-id\",\n  panel: \"data-panel\",\n  panelCollapsible: \"data-panel-collapsible\",\n  panelId: \"data-panel-id\",\n  panelSize: \"data-panel-size\",\n  resizeHandle: \"data-resize-handle\",\n  resizeHandleActive: \"data-resize-handle-active\",\n  resizeHandleEnabled: \"data-panel-resize-handle-enabled\",\n  resizeHandleId: \"data-panel-resize-handle-id\",\n  resizeHandleState: \"data-resize-handle-state\"\n};\nconst PRECISION = 10;\n\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\n\nconst useId = React[\"useId\".toString()];\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    const prevConstraints = {\n      ...constraints\n    };\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSize = collapsedSize;\n    constraints.collapsible = collapsible;\n    constraints.defaultSize = defaultSize;\n    constraints.maxSize = maxSize;\n    constraints.minSize = minSize;\n\n    // If constraints have changed, we should revisit panel sizes.\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\n    }\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: minSize => {\n      expandPanel(panelDataRef.current, minSize);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: panelId,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.panel]: \"\",\n    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || undefined,\n    [DATA_ATTRIBUTES.panelId]: panelId,\n    [DATA_ATTRIBUTES.panelSize]: parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nlet nonce;\nfunction getNonce() {\n  return nonce;\n}\nfunction setNonce(value) {\n  nonce = value;\n}\n\nlet currentCursorStyle = null;\nlet enabled = true;\nlet getCustomCursorStyleFunction = null;\nlet prevRuleIndex = -1;\nlet styleElement = null;\nfunction customizeGlobalCursorStyles(callback) {\n  getCustomCursorStyleFunction = callback;\n}\nfunction disableGlobalCursorStyles() {\n  enabled = false;\n}\nfunction enableGlobalCursorStyles() {\n  enabled = true;\n}\nfunction getCursorStyle(state, constraintFlags, isPointerDown) {\n  const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n  const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n  const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n  const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n  if (getCustomCursorStyleFunction) {\n    return getCustomCursorStyleFunction({\n      exceedsHorizontalMaximum: horizontalMax,\n      exceedsHorizontalMinimum: horizontalMin,\n      exceedsVerticalMaximum: verticalMax,\n      exceedsVerticalMinimum: verticalMin,\n      intersectsHorizontalDragHandle: state === \"horizontal\" || state === \"intersection\",\n      intersectsVerticalDragHandle: state === \"vertical\" || state === \"intersection\",\n      isPointerDown\n    });\n  }\n  if (constraintFlags) {\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n    prevRuleIndex = -1;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags, isPointerDown) {\n  var _styleElement$sheet$i, _styleElement$sheet2;\n  if (!enabled) {\n    return;\n  }\n  const style = getCursorStyle(state, constraintFlags, isPointerDown);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    const nonce = getNonce();\n    if (nonce) {\n      styleElement.setAttribute(\"nonce\", nonce);\n    }\n    document.head.appendChild(styleElement);\n  }\n  if (prevRuleIndex >= 0) {\n    var _styleElement$sheet;\n    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);\n  }\n  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isPointerEvent(event) {\n  return event.type.startsWith(\"pointer\");\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\n\nfunction getResizeEventCoordinates(event) {\n  if (isPointerEvent(event)) {\n    if (event.isPrimary) {\n      return {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n  } else if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\n\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\n\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement | SVGElement} a\n * @param {HTMLElement | SVGElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement | SVGElement} node */\nfunction is_flex_item(node) {\n  var _get_parent;\n  // @ts-ignore\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {(HTMLElement| SVGElement)[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    // @ts-ignore\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  const {\n    parentNode\n  } = node;\n  if (parentNode && parentNode instanceof ShadowRoot) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n\n    // If the resize handle that is currently unmounting is intersecting with the pointer,\n    // update the global pointer to account for the change\n    if (intersectingHandles.includes(data)) {\n      const index = intersectingHandles.indexOf(data);\n      if (index >= 0) {\n        intersectingHandles.splice(index, 1);\n      }\n      updateCursor();\n\n      // Also instruct the handle to stop dragging; this prevents the parent group from being left in an inconsistent state\n      // See github.com/bvaughn/react-resizable-panels/issues/402\n      setResizeHandlerState(\"up\", true, null);\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n\n    // Update cursor based on return value(s) from active handles\n    updateCursor();\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n\n  // Edge case (see #340)\n  // Detect when the pointer has been released outside an iframe on a different domain\n  if (isPointerDown &&\n  // Skip this check for \"pointerleave\" events, else Firefox triggers a false positive (see #514)\n  event.type !== \"pointerleave\" && event.buttons === 0) {\n    isPointerDown = false;\n    updateResizeHandlerStates(\"up\", event);\n  }\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction isWithinResizeHandle(element) {\n  let currentElement = element;\n  while (currentElement) {\n    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {\n      return true;\n    }\n    currentElement = currentElement.parentElement;\n  }\n  return false;\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement || target instanceof SVGElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags, isPointerDown);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags, isPointerDown);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags, isPointerDown);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nlet listenersAbortController;\nfunction updateListeners() {\n  var _listenersAbortContro;\n  (_listenersAbortContro = listenersAbortController) === null || _listenersAbortContro === void 0 ? void 0 : _listenersAbortContro.abort();\n  listenersAbortController = new AbortController();\n  const options = {\n    capture: true,\n    signal: listenersAbortController.signal\n  };\n  if (!registeredResizeHandlers.size) {\n    return;\n  }\n  if (isPointerDown) {\n    if (intersectingHandles.length > 0) {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"contextmenu\", handlePointerUp, options);\n          body.addEventListener(\"pointerleave\", handlePointerMove, options);\n          body.addEventListener(\"pointermove\", handlePointerMove, options);\n        }\n      });\n    }\n    ownerDocumentCounts.forEach((_, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      body.addEventListener(\"pointerup\", handlePointerUp, options);\n      body.addEventListener(\"pointercancel\", handlePointerUp, options);\n    });\n  } else {\n    ownerDocumentCounts.forEach((count, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      if (count > 0) {\n        body.addEventListener(\"pointerdown\", handlePointerDown, options);\n        body.addEventListener(\"pointermove\", handlePointerMove, options);\n      }\n    });\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\n\nfunction useForceUpdate() {\n  const [_, setCount] = useState(0);\n  return useCallback(() => setCount(prevCount => prevCount + 1), []);\n}\n\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too–\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toFixed(3).localeCompare(Math.abs(delta).toFixed(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\n\nfunction calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  assert(firstIndex != null, \"No pivot index found\");\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = constraints;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction isHTMLElement(target) {\n  if (target instanceof HTMLElement) {\n    return true;\n  }\n\n  // Fallback to duck typing to handle edge case of portals within a popup window\n  return typeof target === \"object\" && target !== null && \"tagName\" in target && \"getAttribute\" in target;\n}\n\nfunction getPanelGroupElement(id, rootElement = document) {\n  // If the root element is the PanelGroup\n  if (isHTMLElement(rootElement) && rootElement.dataset.panelGroupId == id) {\n    return rootElement;\n  }\n\n  // Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) ; else {\n        const panelData = panelDataArray[index];\n        assert(panelData, `No panel data found for index \"${index}\"`);\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\n\nfunction calculateUnsafeDefaultLayout({\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toFixed(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toFixed(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\n  var _loadSerializedPanelG, _state$panelKey;\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\n  const panelKey = getPanelKey(panels);\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const forceUpdate = useForceUpdate();\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback((panelData, minSizeOverride) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize = 0,\n        minSize: minSizeFromProps = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n    forceUpdate();\n  }, [forceUpdate]);\n\n  // (Re)calculate group layout whenever panels are registered or unregistered.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsomorphicLayoutEffect(() => {\n    if (eagerValuesRef.current.panelDataArrayChanged) {\n      eagerValuesRef.current.panelDataArrayChanged = false;\n      const {\n        autoSaveId,\n        onLayout,\n        storage\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n\n      // If this panel has been configured to persist sizing information,\n      // default size should be restored from local storage if possible.\n      let unsafeLayout = null;\n      if (autoSaveId) {\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\n        if (state) {\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\n          unsafeLayout = state.layout;\n        }\n      }\n      if (unsafeLayout == null) {\n        unsafeLayout = calculateUnsafeDefaultLayout({\n          panelDataArray\n        });\n      }\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  });\n\n  // Reset the cached layout if hidden by the Activity/Offscreen API\n  useIsomorphicLayoutEffect(() => {\n    const eagerValues = eagerValuesRef.current;\n    return () => {\n      eagerValues.layout = [];\n    };\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    let isRTL = false;\n    const panelGroupElement = panelGroupElementRef.current;\n    if (panelGroupElement) {\n      const style = window.getComputedStyle(panelGroupElement, null);\n      if (style.getPropertyValue(\"direction\") === \"rtl\") {\n        isRTL = true;\n      }\n    }\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n      const isHorizontal = direction === \"horizontal\";\n      if (isHorizontal && isRTL) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isPointerEvent(event) || isMouseEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged && delta !== 0) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n\n  // TODO Multiple drag handles can be active at the same time so this API is a bit awkward now\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n      forceUpdate();\n    }\n  }, [forceUpdate]);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.group]: \"\",\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onBlur,\n  onClick,\n  onDragging,\n  onFocus,\n  onPointerDown,\n  onPointerUp,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  var _hitAreaMargins$coars, _hitAreaMargins$fine;\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onClick,\n    onDragging,\n    onPointerDown,\n    onPointerUp\n  });\n  useEffect(() => {\n    callbacksRef.current.onClick = onClick;\n    callbacksRef.current.onDragging = onDragging;\n    callbacksRef.current.onPointerDown = onPointerDown;\n    callbacksRef.current.onPointerUp = onPointerUp;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.state = state;\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n\n  // Extract hit area margins before passing them to the effect's dependency array\n  // so that inline object values won't trigger re-renders\n  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\n  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    let didMove = false;\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (!isActive) {\n        setState(\"inactive\");\n        return;\n      }\n      switch (action) {\n        case \"down\":\n          {\n            setState(\"drag\");\n            didMove = false;\n            assert(event, 'Expected event to be defined for \"down\" action');\n            startDragging(resizeHandleId, event);\n            const {\n              onDragging,\n              onPointerDown\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(true);\n            onPointerDown === null || onPointerDown === void 0 ? void 0 : onPointerDown();\n            break;\n          }\n        case \"move\":\n          {\n            const {\n              state\n            } = committedValuesRef.current;\n            didMove = true;\n            if (state !== \"drag\") {\n              setState(\"hover\");\n            }\n            assert(event, 'Expected event to be defined for \"move\" action');\n            resizeHandler(event);\n            break;\n          }\n        case \"up\":\n          {\n            setState(\"hover\");\n            stopDragging();\n            const {\n              onClick,\n              onDragging,\n              onPointerUp\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(false);\n            onPointerUp === null || onPointerUp === void 0 ? void 0 : onPointerUp();\n            if (!didMove) {\n              onClick === null || onClick === void 0 ? void 0 : onClick();\n            }\n            break;\n          }\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      coarse: coarseHitAreaMargins,\n      fine: fineHitAreaMargins\n    }, setResizeHandlerState);\n  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => {\n      setIsFocused(false);\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur();\n    },\n    onFocus: () => {\n      setIsFocused(true);\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus();\n    },\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.resizeHandle]: \"\",\n    [DATA_ATTRIBUTES.resizeHandleActive]: state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,\n    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,\n    [DATA_ATTRIBUTES.resizeHandleState]: state\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nfunction usePanelGroupContext() {\n  const context = useContext(PanelGroupContext);\n  return {\n    direction: context === null || context === void 0 ? void 0 : context.direction,\n    groupId: context === null || context === void 0 ? void 0 : context.groupId\n  };\n}\n\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\n\nexport { DATA_ATTRIBUTES, Panel, PanelGroup, PanelResizeHandle, assert, customizeGlobalCursorStyles, disableGlobalCursorStyles, enableGlobalCursorStyles, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects, setNonce, usePanelGroupContext };\n"],"names":["PanelGroupContext","createContext","DATA_ATTRIBUTES","PRECISION","useIsomorphicLayoutEffect","useLayoutEffect","useId","React","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","useRef","PanelWithForwardedRef","children","classNameFromProps","collapsedSize","collapsible","defaultSize","forwardedRef","idFromProps","maxSize","minSize","onCollapse","onExpand","onResize","order","styleFromProps","Type","rest","context","useContext","collapsePanel","expandPanel","getPanelSize","getPanelStyle","groupId","isPanelCollapsed","reevaluatePanelConstraints","registerPanel","resizePanel","unregisterPanel","panelId","panelDataRef","callbacks","constraints","prevConstraints","panelData","useImperativeHandle","size","style","createElement","Panel","forwardRef","props","ref","currentCursorStyle","prevRuleIndex","styleElement","getCursorStyle","state","constraintFlags","isPointerDown","horizontalMin","EXCEEDED_HORIZONTAL_MIN","horizontalMax","EXCEEDED_HORIZONTAL_MAX","verticalMin","EXCEEDED_VERTICAL_MIN","verticalMax","EXCEEDED_VERTICAL_MAX","resetGlobalCursorStyle","setGlobalCursorStyle","_styleElement$sheet$i","_styleElement$sheet2","_styleElement$sheet","isKeyDown","event","isPointerEvent","isMouseEvent","getResizeEventCoordinates","getInputType","intersects","rectOne","rectTwo","strict","compare","a","b","ancestors","get_ancestors","common_ancestor","assert","z_indexes","get_z_index","find_stacking_context","furthest_ancestors","i","child","is_flex_item","node","_get_parent","display","get_parent","creates_stacking_context","nodes","parentNode","isCoarsePointer","intersectingHandles","ownerDocumentCounts","panelConstraintFlags","registeredResizeHandlers","registerResizeHandle","resizeHandleId","element","direction","hitAreaMargins","setResizeHandlerState","_ownerDocumentCounts$","ownerDocument","data","count","updateListeners","_ownerDocumentCounts$2","index","updateCursor","handlePointerDown","target","x","y","recalculateIntersectingHandles","updateResizeHandlerStates","isWithinResizeHandle","handlePointerMove","handlePointerUp","currentElement","targetElement","dragHandleElement","dragHandleRect","bottom","left","right","top","margin","didIntersect","reportConstraintsViolation","flag","intersectsHorizontal","intersectsVertical","listenersAbortController","_listenersAbortContro","options","body","_","action","isActive","useForceUpdate","setCount","useState","useCallback","prevCount","expectedCondition","message","fuzzyCompareNumbers","actual","expected","fractionDigits","fuzzyNumbersEqual$1","fuzzyNumbersEqual","fuzzyLayoutsEqual","actualSize","expectedSize","panelConstraintsArray","panelIndex","panelConstraints","halfwayPoint","adjustLayoutByDelta","delta","initialLayout","pivotIndices","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","prevSize","localDelta","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","unsafeSize","safeSize","pivotIndex","totalSize","total","calculateAriaValues","layout","panelsArray","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","valueMax","valueMin","valueNow","getResizeHandleElementsForGroup","scope","getResizeHandleElementIndex","id","handle","determinePivotIndices","dragHandleId","panelGroupElement","isHTMLElement","getPanelGroupElement","rootElement","getResizeHandleElement","getResizeHandlePanelIds","handleId","_panelsArray$index$id","_panelsArray$index","_panelsArray$id","_panelsArray","handles","idBefore","idAfter","useWindowSplitterPanelGroupBehavior","committedValuesRef","eagerValuesRef","panelDataArray","setLayout","resizeHandleElements","resizeHandleElement","useEffect","eagerValues","groupElement","cleanupFunctions","onKeyDown","cleanupFunction","areEqual","arrayA","arrayB","getResizeEventCursorPosition","isHorizontal","calculateDragOffsetPercentage","initialDragState","handleElement","initialCursorPosition","cursorPosition","groupRect","groupSizeInPixels","calculateDeltaPercentage","keyboardResizeBy","movement","calculateUnsafeDefaultLayout","numPanelsWithSizes","remainingSize","numRemainingPanels","callPanelCallbacks","panelIdToLastNotifiedSizeMap","lastNotifiedSize","compareLayouts","computePanelFlexBoxStyle","dragState","precision","flexGrow","debounce","callback","durationMs","timeoutId","args","initializeDefaultStorage","storageObject","name","value","error","getPanelGroupKey","autoSaveId","getPanelKey","panels","panel","idIsFromProps","loadSerializedPanelGroupState","storage","panelGroupKey","serialized","parsed","loadPanelGroupState","_loadSerializedPanelG","_state$panelKey","panelKey","savePanelGroupState","panelSizesBeforeCollapse","sizes","_loadSerializedPanelG2","validatePanelGroupLayout","nextLayoutTotalSize","accumulated","current","LOCAL_STORAGE_DEBOUNCE_INTERVAL","defaultStorage","debounceMap","PanelGroupWithForwardedRef","onLayout","panelGroupElementRef","setDragState","forceUpdate","panelIdToLastNotifiedSizeMapRef","panelSizeBeforeCollapseRef","prevDeltaRef","unsafeLayout","safeLayout","debouncedSave","clonedPanelDataArray","clonedPanelSizesBeforeCollapse","panelSize","panelDataHelper","findPanelDataIndex","minSizeOverride","minSizeFromProps","prevPanelSize","baseSize","isPanelExpanded","panelA","panelB","orderA","orderB","isRTL","layoutChanged","unsafePanelSize","prevCollapsedSize","prevCollapsible","nextCollapsedSize","nextCollapsible","nextMaxSize","nextMinSize","startDragging","stopDragging","useMemo","PanelGroup","prevPanelData","useWindowSplitterResizeHandlerBehavior","disabled","resizeHandler","nextIndex","PanelResizeHandle","onBlur","onClick","onDragging","onFocus","onPointerDown","onPointerUp","tabIndex","_hitAreaMargins$coars","_hitAreaMargins$fine","elementRef","callbacksRef","panelGroupContext","registerResizeHandleWithParentGroup","setState","isFocused","setIsFocused","setResizeHandler","coarseHitAreaMargins","fineHitAreaMargins","didMove"],"mappings":";;AAKA,MAAMA,KAAoBC,GAAc,IAAI;AAC5CD,GAAkB,cAAc;AAE3B,MAACE,IAAkB;AAAA,EACtB,OAAO;AAAA,EACP,gBAAgB;AAAA,EAChB,SAAS;AAAA,EACT,OAAO;AAAA,EACP,kBAAkB;AAAA,EAClB,SAAS;AAAA,EACT,WAAW;AAAA,EACX,cAAc;AAAA,EACd,oBAAoB;AAAA,EACpB,qBAAqB;AAAA,EACrB,gBAAgB;AAAA,EAChB,mBAAmB;AACrB,GACMC,KAAY,IAEZC,KAA4BC,IAE5BC,KAAQC,GAAM,OACdC,KAAe,OAAOF,MAAU,aAAaA,KAAQ,MAAM;AACjE,IAAIG,KAAU;AACd,SAASC,GAAYC,IAAe,MAAM;AACxC,QAAMC,IAAcJ,GAAY,GAC1BK,IAAQC,EAAOH,KAAgBC,KAAe,IAAI;AACxD,SAAIC,EAAM,YAAY,SACpBA,EAAM,UAAU,KAAKJ,OAEhBE,KAAkEE,EAAM;AACjF;AAEA,SAASE,GAAsB;AAAA,EAC7B,UAAAC;AAAA,EACA,WAAWC,IAAqB;AAAA,EAChC,eAAAC;AAAA,EACA,aAAAC;AAAA,EACA,aAAAC;AAAA,EACA,cAAAC;AAAA,EACA,IAAIC;AAAA,EACJ,SAAAC;AAAA,EACA,SAAAC;AAAA,EACA,YAAAC;AAAA,EACA,UAAAC;AAAA,EACA,UAAAC;AAAA,EACA,OAAAC;AAAA,EACA,OAAOC;AAAA,EACP,SAASC,IAAO;AAAA,EAChB,GAAGC;AACL,GAAG;AACD,QAAMC,IAAUC,GAAWjC,EAAiB;AAC5C,MAAIgC,MAAY;AACd,UAAM,MAAM,iEAAiE;AAE/E,QAAM;AAAA,IACJ,eAAAE;AAAA,IACA,aAAAC;AAAA,IACA,cAAAC;AAAA,IACA,eAAAC;AAAA,IACA,SAAAC;AAAA,IACA,kBAAAC;AAAA,IACA,4BAAAC;AAAA,IACA,eAAAC;AAAA,IACA,aAAAC;AAAA,IACA,iBAAAC;AAAA,EACJ,IAAMX,GACEY,IAAUlC,GAAYY,CAAW,GACjCuB,IAAe/B,EAAO;AAAA,IAC1B,WAAW;AAAA,MACT,YAAAW;AAAA,MACA,UAAAC;AAAA,MACA,UAAAC;AAAA,IACN;AAAA,IACI,aAAa;AAAA,MACX,eAAAT;AAAA,MACA,aAAAC;AAAA,MACA,aAAAC;AAAA,MACA,SAAAG;AAAA,MACA,SAAAC;AAAA,IACN;AAAA,IACI,IAAIoB;AAAA,IACJ,eAAetB,MAAgB;AAAA,IAC/B,OAAAM;AAAA,EACJ,CAAG;AACD,EAAAd,EAAO;AAAA,IACL,iCAAiC;AAAA,EACrC,CAAG,GACDV,GAA0B,MAAM;AAC9B,UAAM;AAAA,MACJ,WAAA0C;AAAA,MACA,aAAAC;AAAA,IACN,IAAQF,EAAa,SACXG,IAAkB;AAAA,MACtB,GAAGD;AAAA,IACT;AACI,IAAAF,EAAa,QAAQ,KAAKD,GAC1BC,EAAa,QAAQ,gBAAgBvB,MAAgB,QACrDuB,EAAa,QAAQ,QAAQjB,GAC7BkB,EAAU,aAAarB,GACvBqB,EAAU,WAAWpB,GACrBoB,EAAU,WAAWnB,GACrBoB,EAAY,gBAAgB7B,GAC5B6B,EAAY,cAAc5B,GAC1B4B,EAAY,cAAc3B,GAC1B2B,EAAY,UAAUxB,GACtBwB,EAAY,UAAUvB,IAIlBwB,EAAgB,kBAAkBD,EAAY,iBAAiBC,EAAgB,gBAAgBD,EAAY,eAAeC,EAAgB,YAAYD,EAAY,WAAWC,EAAgB,YAAYD,EAAY,YACvNP,EAA2BK,EAAa,SAASG,CAAe;AAAA,EAEpE,CAAC,GACD5C,GAA0B,MAAM;AAC9B,UAAM6C,IAAYJ,EAAa;AAC/B,WAAAJ,EAAcQ,CAAS,GAChB,MAAM;AACX,MAAAN,EAAgBM,CAAS;AAAA,IAC3B;AAAA,EACF,GAAG,CAACrB,GAAOgB,GAASH,GAAeE,CAAe,CAAC,GACnDO,GAAoB7B,GAAc,OAAO;AAAA,IACvC,UAAU,MAAM;AACd,MAAAa,EAAcW,EAAa,OAAO;AAAA,IACpC;AAAA,IACA,QAAQ,CAAArB,MAAW;AACjB,MAAAW,EAAYU,EAAa,SAASrB,CAAO;AAAA,IAC3C;AAAA,IACA,QAAQ;AACN,aAAOoB;AAAA,IACT;AAAA,IACA,UAAU;AACR,aAAOR,EAAaS,EAAa,OAAO;AAAA,IAC1C;AAAA,IACA,cAAc;AACZ,aAAON,EAAiBM,EAAa,OAAO;AAAA,IAC9C;AAAA,IACA,aAAa;AACX,aAAO,CAACN,EAAiBM,EAAa,OAAO;AAAA,IAC/C;AAAA,IACA,QAAQ,CAAAM,MAAQ;AACd,MAAAT,EAAYG,EAAa,SAASM,CAAI;AAAA,IACxC;AAAA,EACJ,IAAM,CAACjB,GAAeC,GAAaC,GAAcG,GAAkBK,GAASF,CAAW,CAAC;AACtF,QAAMU,KAAQf,EAAcQ,EAAa,SAASzB,CAAW;AAC7D,SAAOiC,GAAcvB,GAAM;AAAA,IACzB,GAAGC;AAAA,IACH,UAAAf;AAAA,IACA,WAAWC;AAAA,IACX,IAAI2B;AAAA,IACJ,OAAO;AAAA,MACL,GAAGQ;AAAA,MACH,GAAGvB;AAAA,IACT;AAAA;AAAA,IAEI,CAAC3B,EAAgB,OAAO,GAAGoC;AAAA,IAC3B,CAACpC,EAAgB,KAAK,GAAG;AAAA,IACzB,CAACA,EAAgB,gBAAgB,GAAGiB,KAAe;AAAA,IACnD,CAACjB,EAAgB,OAAO,GAAG0C;AAAA,IAC3B,CAAC1C,EAAgB,SAAS,GAAG,WAAW,KAAKkD,GAAM,QAAQ,EAAE,QAAQ,CAAC;AAAA,EAC1E,CAAG;AACH;AACK,MAACE,KAAQC,GAAW,CAACC,GAAOC,MAAQJ,GAActC,IAAuB;AAAA,EAC5E,GAAGyC;AAAA,EACH,cAAcC;AAChB,CAAC,CAAC;AACF1C,GAAsB,cAAc;AACpCuC,GAAM,cAAc;AAUpB,IAAII,KAAqB,MAGrBC,KAAgB,IAChBC,IAAe;AAUnB,SAASC,GAAeC,GAAOC,GAAiBC,GAAe;AAC7D,QAAMC,KAAiBF,IAAkBG,QAA6B,GAChEC,KAAiBJ,IAAkBK,QAA6B,GAChEC,KAAeN,IAAkBO,QAA2B,GAC5DC,KAAeR,IAAkBS,QAA2B;AAYlE,MAAIT,GAAiB;AACnB,QAAIE;AACF,aAAII,IACK,cACEE,IACF,cAEA;AAEJ,QAAIJ;AACT,aAAIE,IACK,cACEE,IACF,cAEA;AAEJ,QAAIF;AACT,aAAO;AACF,QAAIE;AACT,aAAO;AAAA,EAEX;AACA,UAAQT,GAAK;AAAA,IACX,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,EACb;AACA;AACA,SAASW,KAAyB;AAChC,EAAIb,MAAiB,SACnB,SAAS,KAAK,YAAYA,CAAY,GACtCF,KAAqB,MACrBE,IAAe,MACfD,KAAgB;AAEpB;AACA,SAASe,GAAqBZ,GAAOC,GAAiBC,GAAe;AACnE,MAAIW,GAAuBC;AAI3B,QAAMxB,IAAQS,GAAeC,GAAOC,CAA8B;AAClE,MAAIL,OAAuBN,GAY3B;AAAA,QATAM,KAAqBN,GACjBQ,MAAiB,SACnBA,IAAe,SAAS,cAAc,OAAO,GAK7C,SAAS,KAAK,YAAYA,CAAY,IAEpCD,MAAiB,GAAG;AACtB,UAAIkB;AACJ,OAACA,IAAsBjB,EAAa,WAAW,QAAQiB,MAAwB,UAAkBA,EAAoB,WAAWlB,EAAa;AAAA,IAC/I;AACA,IAAAA,MAAiBgB,KAAyBC,IAAuBhB,EAAa,WAAW,QAAQgB,MAAyB,SAAS,SAASA,EAAqB,WAAW,aAAaxB,CAAK,eAAe,OAAO,QAAQuB,MAA0B,SAASA,IAAwB;AAAA;AACzR;AAEA,SAASG,GAAUC,GAAO;AACxB,SAAOA,EAAM,SAAS;AACxB;AACA,SAASC,GAAeD,GAAO;AAC7B,SAAOA,EAAM,KAAK,WAAW,SAAS;AACxC;AACA,SAASE,GAAaF,GAAO;AAC3B,SAAOA,EAAM,KAAK,WAAW,OAAO;AACtC;AAEA,SAASG,GAA0BH,GAAO;AACxC,MAAIC,GAAeD,CAAK;AACtB,QAAIA,EAAM;AACR,aAAO;AAAA,QACL,GAAGA,EAAM;AAAA,QACT,GAAGA,EAAM;AAAA,MACjB;AAAA,aAEaE,GAAaF,CAAK;AAC3B,WAAO;AAAA,MACL,GAAGA,EAAM;AAAA,MACT,GAAGA,EAAM;AAAA,IACf;AAEE,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,EACP;AACA;AAEA,SAASI,KAAe;AACtB,MAAI,OAAO,cAAe;AACxB,WAAO,WAAW,kBAAkB,EAAE,UAAU,WAAW;AAE/D;AAEA,SAASC,GAAWC,GAASC,GAASC,GAAQ;AAE1C,SAAOF,EAAQ,IAAIC,EAAQ,IAAIA,EAAQ,SAASD,EAAQ,IAAIA,EAAQ,QAAQC,EAAQ,KAAKD,EAAQ,IAAIC,EAAQ,IAAIA,EAAQ,UAAUD,EAAQ,IAAIA,EAAQ,SAASC,EAAQ;AAI5K;AAUA,SAASE,GAAQC,GAAGC,GAAG;AACrB,MAAID,MAAMC,EAAG,OAAM,IAAI,MAAM,iCAAiC;AAC9D,QAAMC,IAAY;AAAA,IAChB,GAAGC,GAAcH,CAAC;AAAA,IAClB,GAAGG,GAAcF,CAAC;AAAA,EACtB;AACE,MAAIG;AAGJ,SAAOF,EAAU,EAAE,GAAG,EAAE,MAAMA,EAAU,EAAE,GAAG,EAAE;AAC7C,IAAAF,IAAIE,EAAU,EAAE,IAAG,GACnBD,IAAIC,EAAU,EAAE,IAAG,GACnBE,IAAkBJ;AAEpB,EAAAK,EAAOD,GAAiB,2EAA2E;AACnG,QAAME,IAAY;AAAA,IAChB,GAAGC,GAAYC,GAAsBN,EAAU,CAAC,CAAC;AAAA,IACjD,GAAGK,GAAYC,GAAsBN,EAAU,CAAC,CAAC;AAAA,EACrD;AACE,MAAII,EAAU,MAAMA,EAAU,GAAG;AAC/B,UAAM/E,IAAW6E,EAAgB,YAC3BK,IAAqB;AAAA,MACzB,GAAGP,EAAU,EAAE,GAAG,EAAE;AAAA,MACpB,GAAGA,EAAU,EAAE,GAAG,EAAE;AAAA,IAC1B;AACI,QAAIQ,IAAInF,EAAS;AACjB,WAAOmF,OAAK;AACV,YAAMC,IAAQpF,EAASmF,CAAC;AACxB,UAAIC,MAAUF,EAAmB,EAAG,QAAO;AAC3C,UAAIE,MAAUF,EAAmB,EAAG,QAAO;AAAA,IAC7C;AAAA,EACF;AACA,SAAO,KAAK,KAAKH,EAAU,IAAIA,EAAU,CAAC;AAC5C;AACA,MAAMvC,KAAQ;AAGd,SAAS6C,GAAaC,GAAM;AAC1B,MAAIC;AAEJ,QAAMC,IAAU,kBAAkBD,IAAcE,GAAWH,CAAI,OAAO,QAAQC,MAAgB,SAASA,IAAcD,CAAI,EAAE;AAC3H,SAAOE,MAAY,UAAUA,MAAY;AAC3C;AAGA,SAASE,GAAyBJ,GAAM;AACtC,QAAMlD,IAAQ,iBAAiBkD,CAAI;AAmBnC,SAhBI,GAAAlD,EAAM,aAAa,WAMnBA,EAAM,WAAW,WAAWA,EAAM,aAAa,YAAYiD,GAAaC,CAAI,MAC5E,CAAClD,EAAM,UAAU,KACjB,eAAeA,KAASA,EAAM,cAAc,UAC5C,qBAAqBA,KAASA,EAAM,oBAAoB,UACxD,kBAAkBA,KAASA,EAAM,iBAAiB,YAClD,YAAYA,KAASA,EAAM,WAAW,UACtC,kBAAkBA,KAASA,EAAM,iBAAiB,UAClD,eAAeA,KAASA,EAAM,cAAc,aAC5CI,GAAM,KAAKJ,EAAM,UAAU,KAE3BA,EAAM,4BAA4B;AAExC;AAGA,SAAS6C,GAAsBU,GAAO;AACpC,MAAIR,IAAIQ,EAAM;AACd,SAAOR,OAAK;AACV,UAAMG,IAAOK,EAAMR,CAAC;AAEpB,QADAL,EAAOQ,GAAM,cAAc,GACvBI,GAAyBJ,CAAI,EAAG,QAAOA;AAAA,EAC7C;AACA,SAAO;AACT;AAGA,SAASN,GAAYM,GAAM;AACzB,SAAOA,KAAQ,OAAO,iBAAiBA,CAAI,EAAE,MAAM,KAAK;AAC1D;AAGA,SAASV,GAAcU,GAAM;AAC3B,QAAMX,IAAY,CAAA;AAClB,SAAOW;AACL,IAAAX,EAAU,KAAKW,CAAI,GAEnBA,IAAOG,GAAWH,CAAI;AAExB,SAAOX;AACT;AAGA,SAASc,GAAWH,GAAM;AACxB,QAAM;AAAA,IACJ,YAAAM;AAAA,EACJ,IAAMN;AACJ,SAAIM,KAAcA,aAAsB,aAC/BA,EAAW,OAEbA;AACT;AAEA,MAAM1C,KAA0B,GAC1BE,KAA0B,GAC1BE,KAAwB,GACxBE,KAAwB,GACxBqC,KAAkB1B,GAAY,MAAO;AAC3C,IAAI2B,IAAsB,CAAA,GACtB9C,KAAgB,IAChB+C,IAAsB,oBAAI,IAAG,GAC7BC,KAAuB,oBAAI,IAAG;AAClC,MAAMC,KAA2B,oBAAI,IAAG;AACxC,SAASC,GAAqBC,GAAgBC,GAASC,GAAWC,GAAgBC,GAAuB;AACvG,MAAIC;AACJ,QAAM;AAAA,IACJ,eAAAC;AAAA,EACJ,IAAML,GACEM,IAAO;AAAA,IACX,WAAAL;AAAA,IACA,SAAAD;AAAA,IACA,gBAAAE;AAAA,IACA,uBAAAC;AAAA,EACJ,GACQI,KAASH,IAAwBT,EAAoB,IAAIU,CAAa,OAAO,QAAQD,MAA0B,SAASA,IAAwB;AACtJ,SAAAT,EAAoB,IAAIU,GAAeE,IAAQ,CAAC,GAChDV,GAAyB,IAAIS,CAAI,GACjCE,GAAe,GACR,WAAkC;AACvC,QAAIC;AACJ,IAAAb,GAAqB,OAAOG,CAAc,GAC1CF,GAAyB,OAAOS,CAAI;AACpC,UAAMC,KAASE,IAAyBd,EAAoB,IAAIU,CAAa,OAAO,QAAQI,MAA2B,SAASA,IAAyB;AASzJ,QARAd,EAAoB,IAAIU,GAAeE,IAAQ,CAAC,GAChDC,GAAe,GACXD,MAAU,KACZZ,EAAoB,OAAOU,CAAa,GAKtCX,EAAoB,SAASY,CAAI,GAAG;AACtC,YAAMI,IAAQhB,EAAoB,QAAQY,CAAI;AAC9C,MAAII,KAAS,KACXhB,EAAoB,OAAOgB,GAAO,CAAC,GAErCC,GAAY,GAIZR,EAAsB,MAAM,IAAM,IAAI;AAAA,IACxC;AAAA,EACF;AACF;AACA,SAASS,GAAkBjD,GAAO;AAChC,QAAM;AAAA,IACJ,QAAAkD;AAAA,EACJ,IAAMlD,GACE;AAAA,IACJ,GAAAmD;AAAA,IACA,GAAAC;AAAA,EACJ,IAAMjD,GAA0BH,CAAK;AACnC,EAAAf,KAAgB,IAChBoE,GAA+B;AAAA,IAC7B,QAAAH;AAAA,IACA,GAAAC;AAAA,IACA,GAAAC;AAAA,EACJ,CAAG,GACDP,GAAe,GACXd,EAAoB,SAAS,MAC/BuB,GAA0B,QAAQtD,CAAK,GAGvCgD,GAAY,GACZhD,EAAM,eAAc,GACfuD,GAAqBL,CAAM,KAC9BlD,EAAM,yBAAwB;AAGpC;AACA,SAASwD,GAAkBxD,GAAO;AAChC,QAAM;AAAA,IACJ,GAAAmD;AAAA,IACA,GAAAC;AAAA,EACJ,IAAMjD,GAA0BH,CAAK;AAUnC,MANIf;AAAA,EAEJe,EAAM,SAAS,kBAAkBA,EAAM,YAAY,MACjDf,KAAgB,IAChBqE,GAA0B,MAAMtD,CAAK,IAEnC,CAACf,IAAe;AAClB,UAAM;AAAA,MACJ,QAAAiE;AAAA,IACN,IAAQlD;AAKJ,IAAAqD,GAA+B;AAAA,MAC7B,QAAAH;AAAA,MACA,GAAAC;AAAA,MACA,GAAAC;AAAA,IACN,CAAK;AAAA,EACH;AACA,EAAAE,GAA0B,QAAQtD,CAAK,GAGvCgD,GAAY,GACRjB,EAAoB,SAAS,KAC/B/B,EAAM,eAAc;AAExB;AACA,SAASyD,GAAgBzD,GAAO;AAC9B,QAAM;AAAA,IACJ,QAAAkD;AAAA,EACJ,IAAMlD,GACE;AAAA,IACJ,GAAAmD;AAAA,IACA,GAAAC;AAAA,EACJ,IAAMjD,GAA0BH,CAAK;AACnC,EAAAiC,GAAqB,MAAK,GAC1BhD,KAAgB,IACZ8C,EAAoB,SAAS,MAC/B/B,EAAM,eAAc,GACfuD,GAAqBL,CAAM,KAC9BlD,EAAM,yBAAwB,IAGlCsD,GAA0B,MAAMtD,CAAK,GACrCqD,GAA+B;AAAA,IAC7B,QAAAH;AAAA,IACA,GAAAC;AAAA,IACA,GAAAC;AAAA,EACJ,CAAG,GACDJ,GAAY,GACZH,GAAe;AACjB;AACA,SAASU,GAAqBlB,GAAS;AACrC,MAAIqB,IAAiBrB;AACrB,SAAOqB,KAAgB;AACrB,QAAIA,EAAe,aAAavI,EAAgB,YAAY;AAC1D,aAAO;AAET,IAAAuI,IAAiBA,EAAe;AAAA,EAClC;AACA,SAAO;AACT;AACA,SAASL,GAA+B;AAAA,EACtC,QAAAH;AAAA,EACA,GAAAC;AAAA,EACA,GAAAC;AACF,GAAG;AACD,EAAArB,EAAoB,OAAO,CAAC;AAC5B,MAAI4B,IAAgB;AACpB,GAAIT,aAAkB,eAAeA,aAAkB,gBACrDS,IAAgBT,IAElBhB,GAAyB,QAAQ,CAAAS,MAAQ;AACvC,UAAM;AAAA,MACJ,SAASiB;AAAA,MACT,gBAAArB;AAAA,IACN,IAAQI,GACEkB,IAAiBD,EAAkB,sBAAqB,GACxD;AAAA,MACJ,QAAAE;AAAA,MACA,MAAAC;AAAA,MACA,OAAAC;AAAA,MACA,KAAAC;AAAA,IACN,IAAQJ,GACEK,IAASpC,KAAkBS,EAAe,SAASA,EAAe;AAExE,QADwBY,KAAKY,IAAOG,KAAUf,KAAKa,IAAQE,KAAUd,KAAKa,IAAMC,KAAUd,KAAKU,IAASI,GACnF;AAOnB,UAAIP,MAAkB,QAAQ,SAAS,SAASA,CAAa,KAAKC,MAAsBD,KAAiB,CAACC,EAAkB,SAASD,CAAa,KAAK,CAACA,EAAc,SAASC,CAAiB;AAAA;AAAA;AAAA,MAIhMnD,GAAQkD,GAAeC,CAAiB,IAAI,GAAG;AAO7C,YAAIF,IAAiBC,GACjBQ,IAAe;AACnB,eAAOT,KACD,CAAAA,EAAe,SAASE,CAAiB,KADxB;AAGd,cAAIvD,GAAWqD,EAAe,sBAAqB,GAAIG,CAAoB,GAAG;AACnF,YAAAM,IAAe;AACf;AAAA,UACF;AACA,UAAAT,IAAiBA,EAAe;AAAA,QAClC;AACA,YAAIS;AACF;AAAA,MAEJ;AACA,MAAApC,EAAoB,KAAKY,CAAI;AAAA,IAC/B;AAAA,EACF,CAAC;AACH;AACA,SAASyB,GAA2BhC,GAAgBiC,GAAM;AACxD,EAAApC,GAAqB,IAAIG,GAAgBiC,CAAI;AAC/C;AACA,SAASrB,KAAe;AACtB,MAAIsB,IAAuB,IACvBC,IAAqB;AACzB,EAAAxC,EAAoB,QAAQ,CAAAY,MAAQ;AAClC,UAAM;AAAA,MACJ,WAAAL;AAAA,IACN,IAAQK;AACJ,IAAIL,MAAc,eAChBgC,IAAuB,KAEvBC,IAAqB;AAAA,EAEzB,CAAC;AACD,MAAIvF,IAAkB;AACtB,EAAAiD,GAAqB,QAAQ,CAAAoC,MAAQ;AACnC,IAAArF,KAAmBqF;AAAA,EACrB,CAAC,GACGC,KAAwBC,IAC1B5E,GAAqB,gBAAgBX,CAA8B,IAC1DsF,IACT3E,GAAqB,cAAcX,CAA8B,IACxDuF,IACT5E,GAAqB,YAAYX,CAA8B,IAE/DU,GAAsB;AAE1B;AACA,IAAI8E;AACJ,SAAS3B,KAAkB;AACzB,MAAI4B;AACJ,GAACA,IAAwBD,QAA8B,QAAQC,MAA0B,UAAkBA,EAAsB,MAAK,GACtID,KAA2B,IAAI,gBAAe;AAC9C,QAAME,IAAU;AAAA,IACd,SAAS;AAAA,IACT,QAAQF,GAAyB;AAAA,EACrC;AACE,EAAKtC,GAAyB,SAG1BjD,MACE8C,EAAoB,SAAS,KAC/BC,EAAoB,QAAQ,CAACY,GAAOF,MAAkB;AACpD,UAAM;AAAA,MACJ,MAAAiC;AAAA,IACV,IAAYjC;AACJ,IAAIE,IAAQ,MACV+B,EAAK,iBAAiB,eAAelB,IAAiBiB,CAAO,GAC7DC,EAAK,iBAAiB,gBAAgBnB,IAAmBkB,CAAO,GAChEC,EAAK,iBAAiB,eAAenB,IAAmBkB,CAAO;AAAA,EAEnE,CAAC,GAEH1C,EAAoB,QAAQ,CAAC4C,GAAGlC,MAAkB;AAChD,UAAM;AAAA,MACJ,MAAAiC;AAAA,IACR,IAAUjC;AACJ,IAAAiC,EAAK,iBAAiB,aAAalB,IAAiBiB,CAAO,GAC3DC,EAAK,iBAAiB,iBAAiBlB,IAAiBiB,CAAO;AAAA,EACjE,CAAC,KAED1C,EAAoB,QAAQ,CAACY,GAAOF,MAAkB;AACpD,UAAM;AAAA,MACJ,MAAAiC;AAAA,IACR,IAAUjC;AACJ,IAAIE,IAAQ,MACV+B,EAAK,iBAAiB,eAAe1B,IAAmByB,CAAO,GAC/DC,EAAK,iBAAiB,eAAenB,IAAmBkB,CAAO;AAAA,EAEnE,CAAC;AAEL;AACA,SAASpB,GAA0BuB,GAAQ7E,GAAO;AAChD,EAAAkC,GAAyB,QAAQ,CAAAS,MAAQ;AACvC,UAAM;AAAA,MACJ,uBAAAH;AAAA,IACN,IAAQG,GACEmC,IAAW/C,EAAoB,SAASY,CAAI;AAClD,IAAAH,EAAsBqC,GAAQC,GAAU9E,CAAK;AAAA,EAC/C,CAAC;AACH;AAEA,SAAS+E,KAAiB;AACxB,QAAM,CAACH,GAAGI,CAAQ,IAAIC,GAAS,CAAC;AAChC,SAAOC,EAAY,MAAMF,EAAS,CAAAG,MAAaA,IAAY,CAAC,GAAG,EAAE;AACnE;AAEA,SAASpE,EAAOqE,GAAmBC,GAAS;AAC1C,MAAI,CAACD;AACH,kBAAQ,MAAMC,CAAO,GACf,MAAMA,CAAO;AAEvB;AAEA,SAASC,GAAoBC,GAAQC,GAAUC,IAAiBrK,IAAW;AACzE,SAAImK,EAAO,QAAQE,CAAc,MAAMD,EAAS,QAAQC,CAAc,IAC7D,IAEAF,IAASC,IAAW,IAAI;AAEnC;AACA,SAASE,EAAoBH,GAAQC,GAAUC,IAAiBrK,IAAW;AACzE,SAAOkK,GAAoBC,GAAQC,GAAUC,CAAc,MAAM;AACnE;AAEA,SAASE,EAAkBJ,GAAQC,GAAUC,GAAgB;AAC3D,SAAOH,GAAoBC,GAAQC,GAAUC,CAAc,MAAM;AACnE;AAEA,SAASG,GAAkBL,GAAQC,GAAUC,GAAgB;AAC3D,MAAIF,EAAO,WAAWC,EAAS;AAC7B,WAAO;AAET,WAASzC,IAAQ,GAAGA,IAAQwC,EAAO,QAAQxC,KAAS;AAClD,UAAM8C,IAAaN,EAAOxC,CAAK,GACzB+C,IAAeN,EAASzC,CAAK;AACnC,QAAI,CAAC4C,EAAkBE,GAAYC,GAAcL,CAAc;AAC7D,aAAO;AAAA,EAEX;AACA,SAAO;AACT;AAGA,SAAS9H,GAAY;AAAA,EACnB,kBAAkBoI;AAAA,EAClB,YAAAC;AAAA,EACA,MAAA5H;AACF,GAAG;AACD,QAAM6H,IAAmBF,EAAsBC,CAAU;AACzD,EAAAjF,EAAOkF,KAAoB,MAAM,yCAAyCD,CAAU,EAAE;AACtF,MAAI;AAAA,IACF,eAAA7J,IAAgB;AAAA,IAChB,aAAAC;AAAA,IACA,SAAAI,IAAU;AAAA,IACV,SAAAC,IAAU;AAAA,EACd,IAAMwJ;AACJ,MAAIX,GAAoBlH,GAAM3B,CAAO,IAAI;AACvC,QAAIL,GAAa;AAEf,YAAM8J,KAAgB/J,IAAgBM,KAAW;AACjD,MAAI6I,GAAoBlH,GAAM8H,CAAY,IAAI,IAC5C9H,IAAOjC,IAEPiC,IAAO3B;AAAA,IAEX;AACE,MAAA2B,IAAO3B;AAGX,SAAA2B,IAAO,KAAK,IAAI5B,GAAS4B,CAAI,GAC7BA,IAAO,WAAWA,EAAK,QAAQhD,EAAS,CAAC,GAClCgD;AACT;AAGA,SAAS+H,GAAoB;AAAA,EAC3B,OAAAC;AAAA,EACA,eAAAC;AAAA,EACA,kBAAkBN;AAAA,EAClB,cAAAO;AAAA,EACA,YAAAC;AAAA,EACA,SAAAC;AACF,GAAG;AACD,MAAIb,EAAkBS,GAAO,CAAC;AAC5B,WAAOC;AAET,QAAMI,IAAa,CAAC,GAAGJ,CAAa,GAC9B,CAACK,GAAiBC,CAAgB,IAAIL;AAC5C,EAAAvF,EAAO2F,KAAmB,MAAM,2BAA2B,GAC3D3F,EAAO4F,KAAoB,MAAM,4BAA4B;AAC7D,MAAIC,IAAe;AAsBjB,MAAIJ,MAAY,YAAY;AAC1B;AAEE,YAAMzD,IAAQqD,IAAQ,IAAIO,IAAmBD,GACvCT,IAAmBF,EAAsBhD,CAAK;AACpD,MAAAhC,EAAOkF,GAAkB,yCAAyClD,CAAK,EAAE;AACzE,YAAM;AAAA,QACJ,eAAA5G,IAAgB;AAAA,QAChB,aAAAC;AAAA,QACA,SAAAK,IAAU;AAAA,MACpB,IAAYwJ;AAIJ,UAAI7J,GAAa;AACf,cAAMyK,IAAWR,EAActD,CAAK;AAEpC,YADAhC,EAAO8F,KAAY,MAAM,6CAA6C9D,CAAK,EAAE,GACzE4C,EAAkBkB,GAAU1K,CAAa,GAAG;AAC9C,gBAAM2K,IAAarK,IAAUoK;AAG7B,UAAIvB,GAAoBwB,GAAY,KAAK,IAAIV,CAAK,CAAC,IAAI,MACrDA,IAAQA,IAAQ,IAAI,IAAIU,IAAaA;AAAA,QAGzC;AAAA,MACF;AAAA,IACF;AAEA;AAEE,YAAM/D,IAAQqD,IAAQ,IAAIM,IAAkBC,GACtCV,IAAmBF,EAAsBhD,CAAK;AACpD,MAAAhC,EAAOkF,GAAkB,wCAAwClD,CAAK,EAAE;AACxE,YAAM;AAAA,QACJ,eAAA5G,IAAgB;AAAA,QAChB,aAAAC;AAAA,QACA,SAAAK,IAAU;AAAA,MACpB,IAAYwJ;AAIJ,UAAI7J,GAAa;AACf,cAAMyK,IAAWR,EAActD,CAAK;AAEpC,YADAhC,EAAO8F,KAAY,MAAM,6CAA6C9D,CAAK,EAAE,GACzE4C,EAAkBkB,GAAUpK,CAAO,GAAG;AACxC,gBAAMqK,IAAaD,IAAW1K;AAG9B,UAAImJ,GAAoBwB,GAAY,KAAK,IAAIV,CAAK,CAAC,IAAI,MACrDA,IAAQA,IAAQ,IAAI,IAAIU,IAAaA;AAAA,QAGzC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAIF;AAOE,UAAMC,IAAYX,IAAQ,IAAI,IAAI;AAClC,QAAIrD,IAAQqD,IAAQ,IAAIO,IAAmBD,GACvCM,IAAoB;AAGxB,eAAa;AACX,YAAMH,IAAWR,EAActD,CAAK;AACpC,MAAAhC,EAAO8F,KAAY,MAAM,6CAA6C9D,CAAK,EAAE;AAM7E,YAAMqD,IALczI,GAAY;AAAA,QAC9B,kBAAkBoI;AAAA,QAClB,YAAYhD;AAAA,QACZ,MAAM;AAAA,MACd,CAAO,IAC2B8D;AAK5B,UAFAG,KAAqBZ,GACrBrD,KAASgE,GACLhE,IAAQ,KAAKA,KAASgD,EAAsB;AAC9C;AAAA,IAEJ;AAGA,UAAMkB,IAAc,KAAK,IAAI,KAAK,IAAIb,CAAK,GAAG,KAAK,IAAIY,CAAiB,CAAC;AACzE,IAAAZ,IAAQA,IAAQ,IAAI,IAAIa,IAAcA;AAAA,EAGxC;AAEA;AAIE,QAAIlE,IADeqD,IAAQ,IAAIM,IAAkBC;AAEjD,WAAO5D,KAAS,KAAKA,IAAQgD,EAAsB,UAAQ;AACzD,YAAMmB,IAAiB,KAAK,IAAId,CAAK,IAAI,KAAK,IAAIQ,CAAY,GACxDC,IAAWR,EAActD,CAAK;AACpC,MAAAhC,EAAO8F,KAAY,MAAM,6CAA6C9D,CAAK,EAAE;AAC7E,YAAMoE,IAAaN,IAAWK,GACxBE,IAAWzJ,GAAY;AAAA,QAC3B,kBAAkBoI;AAAA,QAClB,YAAYhD;AAAA,QACZ,MAAMoE;AAAA,MACd,CAAO;AACD,UAAI,CAACxB,EAAkBkB,GAAUO,CAAQ,MACvCR,KAAgBC,IAAWO,GAC3BX,EAAW1D,CAAK,IAAIqE,GAChBR,EAAa,QAAQ,CAAC,EAAE,cAAc,KAAK,IAAIR,CAAK,EAAE,QAAQ,CAAC,GAAG,QAAW;AAAA,QAC/E,SAAS;AAAA,MACnB,CAAS,KAAK;AACJ;AAGJ,MAAIA,IAAQ,IACVrD,MAEAA;AAAA,IAEJ;AAAA,EACF;AAOA,MAAI6C,GAAkBW,GAAYE,CAAU;AAI1C,WAAOF;AAET;AAEE,UAAMc,IAAajB,IAAQ,IAAIO,IAAmBD,GAC5CG,IAAWR,EAAcgB,CAAU;AACzC,IAAAtG,EAAO8F,KAAY,MAAM,6CAA6CQ,CAAU,EAAE;AAClF,UAAMF,IAAaN,IAAWD,GACxBQ,IAAWzJ,GAAY;AAAA,MAC3B,kBAAkBoI;AAAA,MAClB,YAAYsB;AAAA,MACZ,MAAMF;AAAA,IACZ,CAAK;AAMD,QAHAV,EAAWY,CAAU,IAAID,GAGrB,CAACzB,EAAkByB,GAAUD,CAAU,GAAG;AAC5C,UAAID,IAAiBC,IAAaC,GAE9BrE,IADeqD,IAAQ,IAAIO,IAAmBD;AAElD,aAAO3D,KAAS,KAAKA,IAAQgD,EAAsB,UAAQ;AACzD,cAAMc,IAAWJ,EAAW1D,CAAK;AACjC,QAAAhC,EAAO8F,KAAY,MAAM,6CAA6C9D,CAAK,EAAE;AAC7E,cAAMoE,IAAaN,IAAWK,GACxBE,IAAWzJ,GAAY;AAAA,UAC3B,kBAAkBoI;AAAA,UAClB,YAAYhD;AAAA,UACZ,MAAMoE;AAAA,QAChB,CAAS;AAKD,YAJKxB,EAAkBkB,GAAUO,CAAQ,MACvCF,KAAkBE,IAAWP,GAC7BJ,EAAW1D,CAAK,IAAIqE,IAElBzB,EAAkBuB,GAAgB,CAAC;AACrC;AAEF,QAAId,IAAQ,IACVrD,MAEAA;AAAA,MAEJ;AAAA,IACF;AAAA,EACF;AAKA,QAAMuE,IAAYb,EAAW,OAAO,CAACc,GAAOnJ,MAASA,IAAOmJ,GAAO,CAAC;AAKpE,SAAK5B,EAAkB2B,GAAW,GAAG,IAQ9Bb,IAJEF;AAKX;AAEA,SAASiB,GAAoB;AAAA,EAC3B,QAAAC;AAAA,EACA,aAAAC;AAAA,EACA,cAAApB;AACF,GAAG;AACD,MAAIqB,IAAiB,GACjBC,IAAiB,KACjBC,IAAe,GACfC,IAAe;AACnB,QAAMC,IAAazB,EAAa,CAAC;AACjC,EAAAvF,EAAOgH,KAAc,MAAM,sBAAsB,GAGjDL,EAAY,QAAQ,CAACxJ,GAAW6E,MAAU;AACxC,UAAM;AAAA,MACJ,aAAA/E;AAAA,IACN,IAAQE,GACE;AAAA,MACJ,SAAA1B,IAAU;AAAA,MACV,SAAAC,IAAU;AAAA,IAChB,IAAQuB;AACJ,IAAI+E,MAAUgF,KACZJ,IAAiBlL,GACjBmL,IAAiBpL,MAEjBqL,KAAgBpL,GAChBqL,KAAgBtL;AAAA,EAEpB,CAAC;AACD,QAAMwL,IAAW,KAAK,IAAIJ,GAAgB,MAAMC,CAAY,GACtDI,IAAW,KAAK,IAAIN,GAAgB,MAAMG,CAAY,GACtDI,IAAWT,EAAOM,CAAU;AAClC,SAAO;AAAA,IACL,UAAAC;AAAA,IACA,UAAAC;AAAA,IACA,UAAAC;AAAA,EACJ;AACA;AAEA,SAASC,GAAgC5K,GAAS6K,IAAQ,UAAU;AAClE,SAAO,MAAM,KAAKA,EAAM,iBAAiB,IAAIjN,EAAgB,cAAc,0BAA0BoC,CAAO,IAAI,CAAC;AACnH;AAEA,SAAS8K,GAA4B9K,GAAS+K,GAAIF,IAAQ,UAAU;AAElE,QAAMrF,IADUoF,GAAgC5K,GAAS6K,CAAK,EACxC,UAAU,CAAAG,MAAUA,EAAO,aAAapN,EAAgB,cAAc,MAAMmN,CAAE;AACpG,SAAOvF,KAA6C;AACtD;AAEA,SAASyF,GAAsBjL,GAASkL,GAAcC,GAAmB;AACvE,QAAM3F,IAAQsF,GAA4B9K,GAASkL,GAAcC,CAAiB;AAClF,SAAO3F,KAAS,OAAO,CAACA,GAAOA,IAAQ,CAAC,IAAI,CAAC,IAAI,EAAE;AACrD;AAEA,SAAS4F,GAAczF,GAAQ;AAC7B,SAAIA,aAAkB,cACb,KAIF,OAAOA,KAAW,YAAYA,MAAW,QAAQ,aAAaA,KAAU,kBAAkBA;AACnG;AAEA,SAAS0F,GAAqBN,GAAIO,IAAc,UAAU;AAExD,MAAIF,GAAcE,CAAW,KAAKA,EAAY,QAAQ,gBAAgBP;AACpE,WAAOO;AAIT,QAAMxG,IAAUwG,EAAY,cAAc,2CAA2CP,CAAE,IAAI;AAC3F,SAAIjG,KAGG;AACT;AAEA,SAASyG,GAAuBR,GAAIF,IAAQ,UAAU;AACpD,QAAM/F,IAAU+F,EAAM,cAAc,IAAIjN,EAAgB,cAAc,KAAKmN,CAAE,IAAI;AACjF,SAAIjG,KAGG;AACT;AAEA,SAAS0G,GAAwBxL,GAASyL,GAAUtB,GAAaU,IAAQ,UAAU;AACjF,MAAIa,GAAuBC,GAAoBC,GAAiBC;AAChE,QAAMb,IAASO,GAAuBE,GAAUZ,CAAK,GAC/CiB,IAAUlB,GAAgC5K,GAAS6K,CAAK,GACxDrF,IAAQwF,IAASc,EAAQ,QAAQd,CAAM,IAAI,IAC3Ce,KAAYL,KAAyBC,IAAqBxB,EAAY3E,CAAK,OAAO,QAAQmG,MAAuB,SAAS,SAASA,EAAmB,QAAQ,QAAQD,MAA0B,SAASA,IAAwB,MACjOM,KAAWJ,KAAmBC,IAAe1B,EAAY3E,IAAQ,CAAC,OAAO,QAAQqG,MAAiB,SAAS,SAASA,EAAa,QAAQ,QAAQD,MAAoB,SAASA,IAAkB;AACtM,SAAO,CAACG,GAAUC,CAAO;AAC3B;AAIA,SAASC,GAAoC;AAAA,EAC3C,oBAAAC;AAAA,EACA,gBAAAC;AAAA,EACA,SAAAnM;AAAA,EACA,QAAAkK;AAAA,EACA,gBAAAkC;AAAA,EACA,mBAAAjB;AAAA,EACA,WAAAkB;AACF,GAAG;AACD,EAAA7N,EAAO;AAAA,IACL,iCAAiC;AAAA,EACrC,CAAG,GACDV,GAA0B,MAAM;AAC9B,QAAI,CAACqN;AACH;AAEF,UAAMmB,IAAuB1B,GAAgC5K,GAASmL,CAAiB;AACvF,aAAS3F,IAAQ,GAAGA,IAAQ4G,EAAe,SAAS,GAAG5G,KAAS;AAC9D,YAAM;AAAA,QACJ,UAAAiF;AAAA,QACA,UAAAC;AAAA,QACA,UAAAC;AAAA,MACR,IAAUV,GAAoB;AAAA,QACtB,QAAAC;AAAA,QACA,aAAakC;AAAA,QACb,cAAc,CAAC5G,GAAOA,IAAQ,CAAC;AAAA,MACvC,CAAO,GACK+G,IAAsBD,EAAqB9G,CAAK;AACtD,UAAI+G,KAAuB,MAAa;AACtC,cAAM5L,IAAYyL,EAAe5G,CAAK;AACtC,QAAAhC,EAAO7C,GAAW,kCAAkC6E,CAAK,GAAG,GAC5D+G,EAAoB,aAAa,iBAAiB5L,EAAU,EAAE,GAC9D4L,EAAoB,aAAa,iBAAiB,KAAK,KAAK,MAAM9B,CAAQ,CAAC,GAC3E8B,EAAoB,aAAa,iBAAiB,KAAK,KAAK,MAAM7B,CAAQ,CAAC,GAC3E6B,EAAoB,aAAa,iBAAiB5B,KAAY,OAAO,KAAK,KAAK,MAAMA,CAAQ,IAAI,EAAE;AAAA,MACrG;AAAA,IACF;AACA,WAAO,MAAM;AACX,MAAA2B,EAAqB,QAAQ,CAACC,GAAqB/G,MAAU;AAC3D,QAAA+G,EAAoB,gBAAgB,eAAe,GACnDA,EAAoB,gBAAgB,eAAe,GACnDA,EAAoB,gBAAgB,eAAe,GACnDA,EAAoB,gBAAgB,eAAe;AAAA,MACrD,CAAC;AAAA,IACH;AAAA,EACF,GAAG,CAACvM,GAASkK,GAAQkC,GAAgBjB,CAAiB,CAAC,GACvDqB,GAAU,MAAM;AACd,QAAI,CAACrB;AACH;AAEF,UAAMsB,IAAcN,EAAe;AACnC,IAAA3I,EAAOiJ,GAAa,wBAAwB;AAC5C,UAAM;AAAA,MACJ,gBAAAL;AAAA,IACN,IAAQK,GACEC,IAAerB,GAAqBrL,GAASmL,CAAiB;AACpE,IAAA3H,EAAOkJ,KAAgB,MAAM,0BAA0B1M,CAAO,GAAG;AACjE,UAAM8L,IAAUlB,GAAgC5K,GAASmL,CAAiB;AAC1E,IAAA3H,EAAOsI,GAAS,yCAAyC9L,CAAO,GAAG;AACnE,UAAM2M,IAAmBb,EAAQ,IAAI,CAAAd,MAAU;AAC7C,YAAMS,IAAWT,EAAO,aAAapN,EAAgB,cAAc;AACnE,MAAA4F,EAAOiI,GAAU,kDAAkD;AACnE,YAAM,CAACM,GAAUC,CAAO,IAAIR,GAAwBxL,GAASyL,GAAUW,GAAgBjB,CAAiB;AACxG,UAAIY,KAAY,QAAQC,KAAW;AACjC,eAAO,MAAM;AAAA,QAAC;AAEhB,YAAMY,IAAY,CAAAnK,MAAS;AACzB,YAAI,CAAAA,EAAM;AAGV,kBAAQA,EAAM,KAAG;AAAA,YACf,KAAK,SACH;AACE,cAAAA,EAAM,eAAc;AACpB,oBAAM+C,IAAQ4G,EAAe,UAAU,CAAAzL,MAAaA,EAAU,OAAOoL,CAAQ;AAC7E,kBAAIvG,KAAS,GAAG;AACd,sBAAM7E,IAAYyL,EAAe5G,CAAK;AACtC,gBAAAhC,EAAO7C,GAAW,iCAAiC6E,CAAK,EAAE;AAC1D,sBAAM3E,IAAOqJ,EAAO1E,CAAK,GACnB;AAAA,kBACJ,eAAA5G,IAAgB;AAAA,kBAChB,aAAAC;AAAA,kBACA,SAAAK,IAAU;AAAA,gBAC5B,IAAoByB,EAAU;AACd,oBAAIE,KAAQ,QAAQhC,GAAa;AAC/B,wBAAMqK,IAAaN,GAAoB;AAAA,oBACrC,OAAOR,EAAkBvH,GAAMjC,CAAa,IAAIM,IAAUN,IAAgBA,IAAgBiC;AAAA,oBAC1F,eAAeqJ;AAAA,oBACf,kBAAkBkC,EAAe,IAAI,CAAAzL,MAAaA,EAAU,WAAW;AAAA,oBACvE,cAAcsK,GAAsBjL,GAASyL,GAAUN,CAAiB;AAAA,oBACxE,YAAYjB;AAAA,oBACZ,SAAS;AAAA,kBAC7B,CAAmB;AACD,kBAAIA,MAAWhB,KACbmD,EAAUnD,CAAU;AAAA,gBAExB;AAAA,cACF;AACA;AAAA,YACF;AAAA,UACZ;AAAA,MACM;AACA,aAAA8B,EAAO,iBAAiB,WAAW4B,CAAS,GACrC,MAAM;AACX,QAAA5B,EAAO,oBAAoB,WAAW4B,CAAS;AAAA,MACjD;AAAA,IACF,CAAC;AACD,WAAO,MAAM;AACX,MAAAD,EAAiB,QAAQ,CAAAE,MAAmBA,GAAiB;AAAA,IAC/D;AAAA,EACF,GAAG,CAAC1B,GAAmBe,GAAoBC,GAAgBnM,GAASkK,GAAQkC,GAAgBC,CAAS,CAAC;AACxG;AAEA,SAASS,GAASC,GAAQC,GAAQ;AAChC,MAAID,EAAO,WAAWC,EAAO;AAC3B,WAAO;AAET,WAASxH,IAAQ,GAAGA,IAAQuH,EAAO,QAAQvH;AACzC,QAAIuH,EAAOvH,CAAK,MAAMwH,EAAOxH,CAAK;AAChC,aAAO;AAGX,SAAO;AACT;AAEA,SAASyH,GAA6BlI,GAAWtC,GAAO;AACtD,QAAMyK,IAAenI,MAAc,cAC7B;AAAA,IACJ,GAAAa;AAAA,IACA,GAAAC;AAAA,EACJ,IAAMjD,GAA0BH,CAAK;AACnC,SAAOyK,IAAetH,IAAIC;AAC5B;AAEA,SAASsH,GAA8B1K,GAAOyI,GAAcnG,GAAWqI,GAAkBjC,GAAmB;AAC1G,QAAM+B,IAAenI,MAAc,cAC7BsI,IAAgB9B,GAAuBL,GAAcC,CAAiB;AAC5E,EAAA3H,EAAO6J,GAAe,0CAA0CnC,CAAY,GAAG;AAC/E,QAAMlL,IAAUqN,EAAc,aAAazP,EAAgB,OAAO;AAClE,EAAA4F,EAAOxD,GAAS,iDAAiD;AACjE,MAAI;AAAA,IACF,uBAAAsN;AAAA,EACJ,IAAMF;AACJ,QAAMG,IAAiBN,GAA6BlI,GAAWtC,CAAK,GAC9DiK,IAAerB,GAAqBrL,GAASmL,CAAiB;AACpE,EAAA3H,EAAOkJ,GAAc,kCAAkC1M,CAAO,GAAG;AACjE,QAAMwN,IAAYd,EAAa,sBAAqB,GAC9Ce,IAAoBP,IAAeM,EAAU,QAAQA,EAAU;AAGrE,UAFqBD,IAAiBD,KACEG,IAAoB;AAE9D;AAGA,SAASC,GAAyBjL,GAAOyI,GAAcnG,GAAWqI,GAAkBO,GAAkBxC,GAAmB;AACvH,MAAI3I,GAAUC,CAAK,GAAG;AACpB,UAAMyK,IAAenI,MAAc;AACnC,QAAI8D,IAAQ;AACZ,IAAIpG,EAAM,WACRoG,IAAQ,MACC8E,KAAoB,OAC7B9E,IAAQ8E,IAER9E,IAAQ;AAEV,QAAI+E,IAAW;AACf,YAAQnL,EAAM,KAAG;AAAA,MACf,KAAK;AACH,QAAAmL,IAAWV,IAAe,IAAIrE;AAC9B;AAAA,MACF,KAAK;AACH,QAAA+E,IAAWV,IAAe,CAACrE,IAAQ;AACnC;AAAA,MACF,KAAK;AACH,QAAA+E,IAAWV,IAAerE,IAAQ;AAClC;AAAA,MACF,KAAK;AACH,QAAA+E,IAAWV,IAAe,IAAI,CAACrE;AAC/B;AAAA,MACF,KAAK;AACH,QAAA+E,IAAW;AACX;AAAA,MACF,KAAK;AACH,QAAAA,IAAW;AACX;AAAA,IACR;AACI,WAAOA;AAAA,EACT;AACE,WAAIR,KAAoB,OACf,IAEFD,GAA8B1K,GAAOyI,GAAcnG,GAAWqI,GAAkBjC,CAAiB;AAE5G;AAEA,SAAS0C,GAA6B;AAAA,EACpC,gBAAAzB;AACF,GAAG;AACD,QAAMlC,IAAS,MAAMkC,EAAe,MAAM,GACpC5D,IAAwB4D,EAAe,IAAI,CAAAzL,MAAaA,EAAU,WAAW;AACnF,MAAImN,IAAqB,GACrBC,IAAgB;AAGpB,WAASvI,IAAQ,GAAGA,IAAQ4G,EAAe,QAAQ5G,KAAS;AAC1D,UAAMkD,IAAmBF,EAAsBhD,CAAK;AACpD,IAAAhC,EAAOkF,GAAkB,yCAAyClD,CAAK,EAAE;AACzE,UAAM;AAAA,MACJ,aAAA1G;AAAA,IACN,IAAQ4J;AACJ,IAAI5J,KAAe,SACjBgP,KACA5D,EAAO1E,CAAK,IAAI1G,GAChBiP,KAAiBjP;AAAA,EAErB;AAGA,WAAS0G,IAAQ,GAAGA,IAAQ4G,EAAe,QAAQ5G,KAAS;AAC1D,UAAMkD,IAAmBF,EAAsBhD,CAAK;AACpD,IAAAhC,EAAOkF,GAAkB,yCAAyClD,CAAK,EAAE;AACzE,UAAM;AAAA,MACJ,aAAA1G;AAAA,IACN,IAAQ4J;AACJ,QAAI5J,KAAe;AACjB;AAEF,UAAMkP,IAAqB5B,EAAe,SAAS0B,GAC7CjN,IAAOkN,IAAgBC;AAC7B,IAAAF,KACA5D,EAAO1E,CAAK,IAAI3E,GAChBkN,KAAiBlN;AAAA,EACnB;AACA,SAAOqJ;AACT;AAGA,SAAS+D,GAAmB9D,GAAaD,GAAQgE,GAA8B;AAC7E,EAAAhE,EAAO,QAAQ,CAACrJ,GAAM2E,MAAU;AAC9B,UAAM7E,IAAYwJ,EAAY3E,CAAK;AACnC,IAAAhC,EAAO7C,GAAW,kCAAkC6E,CAAK,EAAE;AAC3D,UAAM;AAAA,MACJ,WAAAhF;AAAA,MACA,aAAAC;AAAA,MACA,IAAIH;AAAA,IACV,IAAQK,GACE;AAAA,MACJ,eAAA/B,IAAgB;AAAA,MAChB,aAAAC;AAAA,IACN,IAAQ4B,GACE0N,IAAmBD,EAA6B5N,CAAO;AAC7D,QAAI6N,KAAoB,QAAQtN,MAASsN,GAAkB;AACzD,MAAAD,EAA6B5N,CAAO,IAAIO;AACxC,YAAM;AAAA,QACJ,YAAA1B;AAAA,QACA,UAAAC;AAAA,QACA,UAAAC;AAAA,MACR,IAAUmB;AACJ,MAAInB,KACFA,EAASwB,GAAMsN,CAAgB,GAE7BtP,MAAgBM,KAAcC,OAC5BA,MAAa+O,KAAoB,QAAQhG,EAAoBgG,GAAkBvP,CAAa,MAAM,CAACuJ,EAAoBtH,GAAMjC,CAAa,KAC5IQ,EAAQ,GAEND,MAAegP,KAAoB,QAAQ,CAAChG,EAAoBgG,GAAkBvP,CAAa,MAAMuJ,EAAoBtH,GAAMjC,CAAa,KAC9IO,EAAU;AAAA,IAGhB;AAAA,EACF,CAAC;AACH;AAEA,SAASiP,GAAejL,GAAGC,GAAG;AAC5B,MAAID,EAAE,WAAWC,EAAE;AACjB,WAAO;AAEP,WAASoC,IAAQ,GAAGA,IAAQrC,EAAE,QAAQqC;AACpC,QAAIrC,EAAEqC,CAAK,KAAKpC,EAAEoC,CAAK;AACrB,aAAO;AAIb,SAAO;AACT;AAKA,SAAS6I,GAAyB;AAAA,EAChC,aAAAvP;AAAA,EACA,WAAAwP;AAAA,EACA,QAAApE;AAAA,EACA,WAAAvJ;AAAA,EACA,YAAA8H;AAAA,EACA,WAAA8F,IAAY;AACd,GAAG;AACD,QAAM1N,IAAOqJ,EAAOzB,CAAU;AAC9B,MAAI+F;AACJ,SAAI3N,KAAQ,OAGV2N,IAAW1P,KAAe,OAAYA,EAAY,QAAQyP,CAAS,IAAI,MAC9D5N,EAAU,WAAW,IAE9B6N,IAAW,MAEXA,IAAW3N,EAAK,QAAQ0N,CAAS,GAE5B;AAAA,IACL,WAAW;AAAA,IACX,UAAAC;AAAA,IACA,YAAY;AAAA;AAAA,IAEZ,UAAU;AAAA;AAAA;AAAA,IAGV,eAAeF,MAAc,OAAO,SAAS;AAAA,EACjD;AACA;AAEA,SAASG,GAASC,GAAUC,IAAa,IAAI;AAC3C,MAAIC,IAAY;AAShB,SARe,IAAIC,MAAS;AAC1B,IAAID,MAAc,QAChB,aAAaA,CAAS,GAExBA,IAAY,WAAW,MAAM;AAC3B,MAAAF,EAAS,GAAGG,CAAI;AAAA,IAClB,GAAGF,CAAU;AAAA,EACf;AAEF;AAMA,SAASG,GAAyBC,GAAe;AAC/C,MAAI;AACF,QAAI,OAAO,eAAiB;AAE1B,MAAAA,EAAc,UAAU,CAAAC,MACf,aAAa,QAAQA,CAAI,GAElCD,EAAc,UAAU,CAACC,GAAMC,MAAU;AACvC,qBAAa,QAAQD,GAAMC,CAAK;AAAA,MAClC;AAAA;AAEA,YAAM,IAAI,MAAM,gDAAgD;AAAA,EAEpE,SAASC,GAAO;AACd,YAAQ,MAAMA,CAAK,GACnBH,EAAc,UAAU,MAAM,MAC9BA,EAAc,UAAU,MAAM;AAAA,IAAC;AAAA,EACjC;AACF;AAEA,SAASI,GAAiBC,GAAY;AACpC,SAAO,0BAA0BA,CAAU;AAC7C;AAMA,SAASC,GAAYC,GAAQ;AAC3B,SAAOA,EAAO,IAAI,CAAAC,MAAS;AACzB,UAAM;AAAA,MACJ,aAAA9O;AAAA,MACA,IAAAsK;AAAA,MACA,eAAAyE;AAAA,MACA,OAAAlQ;AAAA,IACN,IAAQiQ;AACJ,WAAIC,IACKzE,IAEAzL,IAAQ,GAAGA,CAAK,IAAI,KAAK,UAAUmB,CAAW,CAAC,KAAK,KAAK,UAAUA,CAAW;AAAA,EAEzF,CAAC,EAAE,KAAK,CAAC0C,GAAGC,MAAMD,EAAE,cAAcC,CAAC,CAAC,EAAE,KAAK,GAAG;AAChD;AACA,SAASqM,GAA8BL,GAAYM,GAAS;AAC1D,MAAI;AACF,UAAMC,IAAgBR,GAAiBC,CAAU,GAC3CQ,IAAaF,EAAQ,QAAQC,CAAa;AAChD,QAAIC,GAAY;AACd,YAAMC,IAAS,KAAK,MAAMD,CAAU;AACpC,UAAI,OAAOC,KAAW,YAAYA,KAAU;AAC1C,eAAOA;AAAA,IAEX;AAAA,EACF,QAAgB;AAAA,EAAC;AACjB,SAAO;AACT;AACA,SAASC,GAAoBV,GAAYE,GAAQI,GAAS;AACxD,MAAIK,GAAuBC;AAC3B,QAAMxO,KAASuO,IAAwBN,GAA8BL,GAAYM,CAAO,OAAO,QAAQK,MAA0B,SAASA,IAAwB,CAAA,GAC5JE,IAAWZ,GAAYC,CAAM;AACnC,UAAQU,IAAkBxO,EAAMyO,CAAQ,OAAO,QAAQD,MAAoB,SAASA,IAAkB;AACxG;AACA,SAASE,GAAoBd,GAAYE,GAAQa,GAA0BC,GAAOV,GAAS;AACzF,MAAIW;AACJ,QAAMV,IAAgBR,GAAiBC,CAAU,GAC3Ca,IAAWZ,GAAYC,CAAM,GAC7B9N,KAAS6O,IAAyBZ,GAA8BL,GAAYM,CAAO,OAAO,QAAQW,MAA2B,SAASA,IAAyB,CAAA;AACrK,EAAA7O,EAAMyO,CAAQ,IAAI;AAAA,IAChB,eAAe,OAAO,YAAYE,EAAyB,QAAO,CAAE;AAAA,IACpE,QAAQC;AAAA,EACZ;AACE,MAAI;AACF,IAAAV,EAAQ,QAAQC,GAAe,KAAK,UAAUnO,CAAK,CAAC;AAAA,EACtD,SAAS0N,GAAO;AACd,YAAQ,MAAMA,CAAK;AAAA,EACrB;AACF;AAGA,SAASoB,GAAyB;AAAA,EAChC,QAAQtH;AAAA,EACR,kBAAAN;AACF,GAAG;AACD,QAAMQ,IAAa,CAAC,GAAGF,CAAU,GAC3BuH,IAAsBrH,EAAW,OAAO,CAACsH,GAAaC,MAAYD,IAAcC,GAAS,CAAC;AAGhG,MAAIvH,EAAW,WAAWR,EAAiB;AACzC,UAAM,MAAM,WAAWA,EAAiB,MAAM,kBAAkBQ,EAAW,IAAI,CAAArI,MAAQ,GAAGA,CAAI,GAAG,EAAE,KAAK,IAAI,CAAC,EAAE;AAC1G,MAAI,CAACuH,EAAkBmI,GAAqB,GAAG,KAAKrH,EAAW,SAAS;AAC7E,aAAS1D,IAAQ,GAAGA,IAAQkD,EAAiB,QAAQlD,KAAS;AAC5D,YAAMoE,IAAaV,EAAW1D,CAAK;AACnC,MAAAhC,EAAOoG,KAAc,MAAM,kCAAkCpE,CAAK,EAAE;AACpE,YAAMqE,IAAW,MAAM0G,IAAsB3G;AAC7C,MAAAV,EAAW1D,CAAK,IAAIqE;AAAA,IACtB;AAEF,MAAIkE,IAAgB;AAGpB,WAASvI,IAAQ,GAAGA,IAAQkD,EAAiB,QAAQlD,KAAS;AAC5D,UAAMoE,IAAaV,EAAW1D,CAAK;AACnC,IAAAhC,EAAOoG,KAAc,MAAM,kCAAkCpE,CAAK,EAAE;AACpE,UAAMqE,IAAWzJ,GAAY;AAAA,MAC3B,kBAAAsI;AAAA,MACA,YAAYlD;AAAA,MACZ,MAAMoE;AAAA,IACZ,CAAK;AACD,IAAIA,KAAcC,MAChBkE,KAAiBnE,IAAaC,GAC9BX,EAAW1D,CAAK,IAAIqE;AAAA,EAExB;AAIA,MAAI,CAACzB,EAAkB2F,GAAe,CAAC;AACrC,aAASvI,IAAQ,GAAGA,IAAQkD,EAAiB,QAAQlD,KAAS;AAC5D,YAAM8D,IAAWJ,EAAW1D,CAAK;AACjC,MAAAhC,EAAO8F,KAAY,MAAM,kCAAkC9D,CAAK,EAAE;AAClE,YAAMoE,IAAaN,IAAWyE,GACxBlE,IAAWzJ,GAAY;AAAA,QAC3B,kBAAAsI;AAAA,QACA,YAAYlD;AAAA,QACZ,MAAMoE;AAAA,MACd,CAAO;AACD,UAAIN,MAAaO,MACfkE,KAAiBlE,IAAWP,GAC5BJ,EAAW1D,CAAK,IAAIqE,GAGhBzB,EAAkB2F,GAAe,CAAC;AACpC;AAAA,IAGN;AAEF,SAAO7E;AACT;AAEA,MAAMwH,KAAkC,KAClCC,KAAiB;AAAA,EACrB,SAAS,CAAA3B,OACPF,GAAyB6B,EAAc,GAChCA,GAAe,QAAQ3B,CAAI;AAAA,EAEpC,SAAS,CAACA,GAAMC,MAAU;AACxB,IAAAH,GAAyB6B,EAAc,GACvCA,GAAe,QAAQ3B,GAAMC,CAAK;AAAA,EACpC;AACF,GACM2B,KAAc,CAAA;AACpB,SAASC,GAA2B;AAAA,EAClC,YAAAzB,IAAa;AAAA,EACb,UAAA1Q;AAAA,EACA,WAAWC,IAAqB;AAAA,EAChC,WAAAoG;AAAA,EACA,cAAAhG;AAAA,EACA,IAAIC,IAAc;AAAA,EAClB,UAAA8R,IAAW;AAAA,EACX,kBAAAnD,IAAmB;AAAA,EACnB,SAAA+B,IAAUiB;AAAA,EACV,OAAOpR;AAAA,EACP,SAASC,IAAO;AAAA,EAChB,GAAGC;AACL,GAAG;AACD,QAAMO,IAAU5B,GAAYY,CAAW,GACjC+R,IAAuBvS,EAAO,IAAI,GAClC,CAAC8P,GAAW0C,CAAY,IAAItJ,GAAS,IAAI,GACzC,CAACwC,GAAQmC,CAAS,IAAI3E,GAAS,CAAA,CAAE,GACjCuJ,IAAczJ,GAAc,GAC5B0J,IAAkC1S,EAAO,EAAE,GAC3C2S,IAA6B3S,EAAO,oBAAI,KAAK,GAC7C4S,IAAe5S,EAAO,CAAC,GACvB0N,IAAqB1N,EAAO;AAAA,IAChC,YAAA4Q;AAAA,IACA,WAAArK;AAAA,IACA,WAAAuJ;AAAA,IACA,IAAItO;AAAA,IACJ,kBAAA2N;AAAA,IACA,UAAAmD;AAAA,IACA,SAAApB;AAAA,EACJ,CAAG,GACKvD,IAAiB3N,EAAO;AAAA,IAC5B,QAAA0L;AAAA,IACA,gBAAgB,CAAA;AAAA,IAChB,uBAAuB;AAAA,EAC3B,CAAG;AACD,EAAA1L,EAAO;AAAA,IACL,yBAAyB;AAAA,IACzB,+BAA+B;AAAA,IAC/B,cAAc,CAAA;AAAA,EAClB,CAAG,GACDoC,GAAoB7B,GAAc,OAAO;AAAA,IACvC,OAAO,MAAMmN,EAAmB,QAAQ;AAAA,IACxC,WAAW,MAAM;AACf,YAAM;AAAA,QACJ,QAAAhC;AAAA,MACR,IAAUiC,EAAe;AACnB,aAAOjC;AAAA,IACT;AAAA,IACA,WAAW,CAAAmH,MAAgB;AACzB,YAAM;AAAA,QACJ,UAAAP;AAAA,MACR,IAAU5E,EAAmB,SACjB;AAAA,QACJ,QAAQlD;AAAA,QACR,gBAAAoD;AAAA,MACR,IAAUD,EAAe,SACbmF,IAAahB,GAAyB;AAAA,QAC1C,QAAQe;AAAA,QACR,kBAAkBjF,EAAe,IAAI,CAAAzL,MAAaA,EAAU,WAAW;AAAA,MAC/E,CAAO;AACD,MAAKmM,GAAS9D,GAAYsI,CAAU,MAClCjF,EAAUiF,CAAU,GACpBnF,EAAe,QAAQ,SAASmF,GAC5BR,KACFA,EAASQ,CAAU,GAErBrD,GAAmB7B,GAAgBkF,GAAYJ,EAAgC,OAAO;AAAA,IAE1F;AAAA,EACJ,IAAM,CAAA,CAAE,GACNpT,GAA0B,MAAM;AAC9B,IAAAoO,EAAmB,QAAQ,aAAakD,GACxClD,EAAmB,QAAQ,YAAYnH,GACvCmH,EAAmB,QAAQ,YAAYoC,GACvCpC,EAAmB,QAAQ,KAAKlM,GAChCkM,EAAmB,QAAQ,WAAW4E,GACtC5E,EAAmB,QAAQ,UAAUwD;AAAA,EACvC,CAAC,GACDzD,GAAoC;AAAA,IAClC,oBAAAC;AAAA,IACA,gBAAAC;AAAA,IACA,SAAAnM;AAAA,IACA,QAAAkK;AAAA,IACA,gBAAgBiC,EAAe,QAAQ;AAAA,IACvC,WAAAE;AAAA,IACA,mBAAmB0E,EAAqB;AAAA,EAC5C,CAAG,GACDvE,GAAU,MAAM;AACd,UAAM;AAAA,MACJ,gBAAAJ;AAAA,IACN,IAAQD,EAAe;AAGnB,QAAIiD,GAAY;AACd,UAAIlF,EAAO,WAAW,KAAKA,EAAO,WAAWkC,EAAe;AAC1D;AAEF,UAAImF,IAAgBX,GAAYxB,CAAU;AAG1C,MAAImC,KAAiB,SACnBA,IAAgB9C,GAASyB,IAAqBQ,EAA+B,GAC7EE,GAAYxB,CAAU,IAAImC;AAK5B,YAAMC,IAAuB,CAAC,GAAGpF,CAAc,GACzCqF,IAAiC,IAAI,IAAIN,EAA2B,OAAO;AACjF,MAAAI,EAAcnC,GAAYoC,GAAsBC,GAAgCvH,GAAQwF,CAAO;AAAA,IACjG;AAAA,EACF,GAAG,CAACN,GAAYlF,GAAQwF,CAAO,CAAC,GAGhClD,GAAU,MAAM;AAAA,EAChB,CAAC;AAGD,QAAM5M,IAAgB+H,EAAY,CAAAhH,MAAa;AAC7C,UAAM;AAAA,MACJ,UAAAmQ;AAAA,IACN,IAAQ5E,EAAmB,SACjB;AAAA,MACJ,QAAQlD;AAAA,MACR,gBAAAoD;AAAA,IACN,IAAQD,EAAe;AACnB,QAAIxL,EAAU,YAAY,aAAa;AACrC,YAAM6H,IAAwB4D,EAAe,IAAI,CAAAzL,MAAaA,EAAU,WAAW,GAC7E;AAAA,QACJ,eAAA/B,IAAgB;AAAA,QAChB,WAAA8S;AAAA,QACA,cAAA3I;AAAA,MACR,IAAU4I,GAAgBvF,GAAgBzL,GAAWqI,CAAU;AAEzD,UADAxF,EAAOkO,KAAa,MAAM,mCAAmC/Q,EAAU,EAAE,GAAG,GACxE,CAACwH,EAAoBuJ,GAAW9S,CAAa,GAAG;AAGlD,QAAAuS,EAA2B,QAAQ,IAAIxQ,EAAU,IAAI+Q,CAAS;AAE9D,cAAM7I,IADc+I,GAAmBxF,GAAgBzL,CAAS,MAAMyL,EAAe,SAAS,IAClEsF,IAAY9S,IAAgBA,IAAgB8S,GAClExI,IAAaN,GAAoB;AAAA,UACrC,OAAAC;AAAA,UACA,eAAeG;AAAA,UACf,kBAAkBR;AAAA,UAClB,cAAAO;AAAA,UACA,YAAAC;AAAA,UACA,SAAS;AAAA,QACnB,CAAS;AACD,QAAKoF,GAAepF,GAAYE,CAAU,MACxCmD,EAAUnD,CAAU,GACpBiD,EAAe,QAAQ,SAASjD,GAC5B4H,KACFA,EAAS5H,CAAU,GAErB+E,GAAmB7B,GAAgBlD,GAAYgI,EAAgC,OAAO;AAAA,MAE1F;AAAA,IACF;AAAA,EACF,GAAG,CAAA,CAAE,GAGCrR,IAAc8H,EAAY,CAAChH,GAAWkR,MAAoB;AAC9D,UAAM;AAAA,MACJ,UAAAf;AAAA,IACN,IAAQ5E,EAAmB,SACjB;AAAA,MACJ,QAAQlD;AAAA,MACR,gBAAAoD;AAAA,IACN,IAAQD,EAAe;AACnB,QAAIxL,EAAU,YAAY,aAAa;AACrC,YAAM6H,IAAwB4D,EAAe,IAAI,CAAAzL,MAAaA,EAAU,WAAW,GAC7E;AAAA,QACJ,eAAA/B,IAAgB;AAAA,QAChB,WAAA8S,IAAY;AAAA,QACZ,SAASI,IAAmB;AAAA,QAC5B,cAAA/I;AAAA,MACR,IAAU4I,GAAgBvF,GAAgBzL,GAAWqI,CAAU,GACnD9J,IAAU2S,KAA2EC;AAC3F,UAAI3J,EAAoBuJ,GAAW9S,CAAa,GAAG;AAEjD,cAAMmT,IAAgBZ,EAA2B,QAAQ,IAAIxQ,EAAU,EAAE,GACnEqR,KAAWD,KAAiB,QAAQA,KAAiB7S,IAAU6S,IAAgB7S,GAE/E2J,KADc+I,GAAmBxF,GAAgBzL,CAAS,MAAMyL,EAAe,SAAS,IAClEsF,IAAYM,KAAWA,KAAWN,GACxDxI,IAAaN,GAAoB;AAAA,UACrC,OAAAC;AAAA,UACA,eAAeG;AAAA,UACf,kBAAkBR;AAAA,UAClB,cAAAO;AAAA,UACA,YAAAC;AAAA,UACA,SAAS;AAAA,QACnB,CAAS;AACD,QAAKoF,GAAepF,GAAYE,CAAU,MACxCmD,EAAUnD,CAAU,GACpBiD,EAAe,QAAQ,SAASjD,GAC5B4H,KACFA,EAAS5H,CAAU,GAErB+E,GAAmB7B,GAAgBlD,GAAYgI,EAAgC,OAAO;AAAA,MAE1F;AAAA,IACF;AAAA,EACF,GAAG,CAAA,CAAE,GAGCpR,IAAe6H,EAAY,CAAAhH,MAAa;AAC5C,UAAM;AAAA,MACJ,QAAAuJ;AAAA,MACA,gBAAAkC;AAAA,IACN,IAAQD,EAAe,SACb;AAAA,MACJ,WAAAuF;AAAA,IACN,IAAQC,GAAgBvF,GAAgBzL,GAAWuJ,CAAM;AACrD,WAAA1G,EAAOkO,KAAa,MAAM,mCAAmC/Q,EAAU,EAAE,GAAG,GACrE+Q;AAAA,EACT,GAAG,CAAA,CAAE,GAGC3R,IAAgB4H,EAAY,CAAChH,GAAW7B,MAAgB;AAC5D,UAAM;AAAA,MACJ,gBAAAsN;AAAA,IACN,IAAQD,EAAe,SACb1D,IAAamJ,GAAmBxF,GAAgBzL,CAAS;AAC/D,WAAO0N,GAAyB;AAAA,MAC9B,aAAAvP;AAAA,MACA,WAAAwP;AAAA,MACA,QAAApE;AAAA,MACA,WAAWkC;AAAA,MACX,YAAA3D;AAAA,IACN,CAAK;AAAA,EACH,GAAG,CAAC6F,GAAWpE,CAAM,CAAC,GAGhBjK,IAAmB0H,EAAY,CAAAhH,MAAa;AAChD,UAAM;AAAA,MACJ,QAAAuJ;AAAA,MACA,gBAAAkC;AAAA,IACN,IAAQD,EAAe,SACb;AAAA,MACJ,eAAAvN,IAAgB;AAAA,MAChB,aAAAC;AAAA,MACA,WAAA6S;AAAA,IACN,IAAQC,GAAgBvF,GAAgBzL,GAAWuJ,CAAM;AACrD,WAAA1G,EAAOkO,KAAa,MAAM,mCAAmC/Q,EAAU,EAAE,GAAG,GACrE9B,MAAgB,MAAQsJ,EAAoBuJ,GAAW9S,CAAa;AAAA,EAC7E,GAAG,CAAA,CAAE,GAGCqT,KAAkBtK,EAAY,CAAAhH,MAAa;AAC/C,UAAM;AAAA,MACJ,QAAAuJ;AAAA,MACA,gBAAAkC;AAAA,IACN,IAAQD,EAAe,SACb;AAAA,MACJ,eAAAvN,IAAgB;AAAA,MAChB,aAAAC;AAAA,MACA,WAAA6S;AAAA,IACN,IAAQC,GAAgBvF,GAAgBzL,GAAWuJ,CAAM;AACrD,WAAA1G,EAAOkO,KAAa,MAAM,mCAAmC/Q,EAAU,EAAE,GAAG,GACrE,CAAC9B,KAAekJ,GAAoB2J,GAAW9S,CAAa,IAAI;AAAA,EACzE,GAAG,CAAA,CAAE,GACCuB,IAAgBwH,EAAY,CAAAhH,MAAa;AAC7C,UAAM;AAAA,MACJ,gBAAAyL;AAAA,IACN,IAAQD,EAAe;AACnB,IAAAC,EAAe,KAAKzL,CAAS,GAC7ByL,EAAe,KAAK,CAAC8F,GAAQC,MAAW;AACtC,YAAMC,IAASF,EAAO,OAChBG,IAASF,EAAO;AACtB,aAAIC,KAAU,QAAQC,KAAU,OACvB,IACED,KAAU,OACZ,KACEC,KAAU,OACZ,IAEAD,IAASC;AAAA,IAEpB,CAAC,GACDlG,EAAe,QAAQ,wBAAwB,IAC/C8E,EAAW;AAAA,EACb,GAAG,CAACA,CAAW,CAAC;AAIhB,EAAAnT,GAA0B,MAAM;AAC9B,QAAIqO,EAAe,QAAQ,uBAAuB;AAChD,MAAAA,EAAe,QAAQ,wBAAwB;AAC/C,YAAM;AAAA,QACJ,YAAAiD;AAAA,QACA,UAAA0B;AAAA,QACA,SAAApB;AAAA,MACR,IAAUxD,EAAmB,SACjB;AAAA,QACJ,QAAQlD;AAAA,QACR,gBAAAoD;AAAA,MACR,IAAUD,EAAe;AAInB,UAAIkF,IAAe;AACnB,UAAIjC,GAAY;AACd,cAAM5N,IAAQsO,GAAoBV,GAAYhD,GAAgBsD,CAAO;AACrE,QAAIlO,MACF2P,EAA2B,UAAU,IAAI,IAAI,OAAO,QAAQ3P,EAAM,aAAa,CAAC,GAChF6P,IAAe7P,EAAM;AAAA,MAEzB;AACA,MAAI6P,KAAgB,SAClBA,IAAexD,GAA6B;AAAA,QAC1C,gBAAAzB;AAAA,MACV,CAAS;AAKH,YAAMlD,IAAaoH,GAAyB;AAAA,QAC1C,QAAQe;AAAA,QACR,kBAAkBjF,EAAe,IAAI,CAAAzL,MAAaA,EAAU,WAAW;AAAA,MAC/E,CAAO;AACD,MAAKmM,GAAS9D,GAAYE,CAAU,MAClCmD,EAAUnD,CAAU,GACpBiD,EAAe,QAAQ,SAASjD,GAC5B4H,KACFA,EAAS5H,CAAU,GAErB+E,GAAmB7B,GAAgBlD,GAAYgI,EAAgC,OAAO;AAAA,IAE1F;AAAA,EACF,CAAC,GAGDpT,GAA0B,MAAM;AAC9B,UAAM2O,IAAcN,EAAe;AACnC,WAAO,MAAM;AACX,MAAAM,EAAY,SAAS,CAAA;AAAA,IACvB;AAAA,EACF,GAAG,CAAA,CAAE;AACL,QAAM7H,IAAuB+C,EAAY,CAAAuD,MAAgB;AACvD,QAAIoH,IAAQ;AACZ,UAAMnH,IAAoB4F,EAAqB;AAC/C,WAAI5F,KACY,OAAO,iBAAiBA,GAAmB,IAAI,EACnD,iBAAiB,WAAW,MAAM,UAC1CmH,IAAQ,KAGL,SAAuB7P,GAAO;AACnC,MAAAA,EAAM,eAAc;AACpB,YAAM0I,IAAoB4F,EAAqB;AAC/C,UAAI,CAAC5F;AACH,eAAO,MAAM;AAEf,YAAM;AAAA,QACJ,WAAApG;AAAA,QACA,WAAAuJ;AAAA,QACA,IAAItO;AAAA,QACJ,kBAAA2N;AAAA,QACA,UAAAmD;AAAA,MACR,IAAU5E,EAAmB,SACjB;AAAA,QACJ,QAAQlD;AAAA,QACR,gBAAAoD;AAAA,MACR,IAAUD,EAAe,SACb;AAAA,QACJ,eAAArD;AAAA,MACR,IAAUwF,KAAyD,CAAA,GACvDvF,KAAekC,GAAsBjL,GAASkL,GAAcC,CAAiB;AACnF,UAAItC,IAAQ6E,GAAyBjL,GAAOyI,GAAcnG,GAAWuJ,GAAWX,GAAkBxC,CAAiB;AACnH,YAAM+B,KAAenI,MAAc;AACnC,MAAImI,MAAgBoF,MAClBzJ,IAAQ,CAACA;AAEX,YAAMH,KAAmB0D,GAAe,IAAI,CAAAzL,OAAaA,GAAU,WAAW,GACxEuI,KAAaN,GAAoB;AAAA,QACrC,OAAAC;AAAA,QACA,eAAeC,MAAqEE;AAAA,QACpF,kBAAAN;AAAA,QACA,cAAAK;AAAA,QACA,YAAAC;AAAA,QACA,SAASxG,GAAUC,CAAK,IAAI,aAAa;AAAA,MACjD,CAAO,GACK8P,KAAgB,CAACnE,GAAepF,GAAYE,EAAU;AAI5D,OAAIxG,GAAeD,CAAK,KAAKE,GAAaF,CAAK,MAIzC2O,EAAa,WAAWvI,MAC1BuI,EAAa,UAAUvI,GACnB,CAAC0J,MAAiB1J,MAAU,IAG1BqE,KACFrG,GAA2BqE,GAAcrC,IAAQ,IAAIjH,KAA0BE,EAAuB,IAEtG+E,GAA2BqE,GAAcrC,IAAQ,IAAI7G,KAAwBE,EAAqB,IAGpG2E,GAA2BqE,GAAc,CAAC,IAI5CqH,OACFlG,EAAUnD,EAAU,GACpBiD,EAAe,QAAQ,SAASjD,IAC5B4H,KACFA,EAAS5H,EAAU,GAErB+E,GAAmB7B,IAAgBlD,IAAYgI,EAAgC,OAAO;AAAA,IAE1F;AAAA,EACF,GAAG,CAAA,CAAE,GAGC9Q,IAAcuH,EAAY,CAAChH,GAAW6R,MAAoB;AAC9D,UAAM;AAAA,MACJ,UAAA1B;AAAA,IACN,IAAQ5E,EAAmB,SACjB;AAAA,MACJ,QAAQlD;AAAA,MACR,gBAAAoD;AAAA,IACN,IAAQD,EAAe,SACb3D,IAAwB4D,EAAe,IAAI,CAAAzL,MAAaA,EAAU,WAAW,GAC7E;AAAA,MACJ,WAAA+Q;AAAA,MACA,cAAA3I;AAAA,IACN,IAAQ4I,GAAgBvF,GAAgBzL,GAAWqI,CAAU;AACzD,IAAAxF,EAAOkO,KAAa,MAAM,mCAAmC/Q,EAAU,EAAE,GAAG;AAE5E,UAAMkI,IADc+I,GAAmBxF,GAAgBzL,CAAS,MAAMyL,EAAe,SAAS,IAClEsF,IAAYc,IAAkBA,IAAkBd,GACtExI,IAAaN,GAAoB;AAAA,MACrC,OAAAC;AAAA,MACA,eAAeG;AAAA,MACf,kBAAkBR;AAAA,MAClB,cAAAO;AAAA,MACA,YAAAC;AAAA,MACA,SAAS;AAAA,IACf,CAAK;AACD,IAAKoF,GAAepF,GAAYE,CAAU,MACxCmD,EAAUnD,CAAU,GACpBiD,EAAe,QAAQ,SAASjD,GAC5B4H,KACFA,EAAS5H,CAAU,GAErB+E,GAAmB7B,GAAgBlD,GAAYgI,EAAgC,OAAO;AAAA,EAE1F,GAAG,CAAA,CAAE,GACChR,KAA6ByH,EAAY,CAAChH,GAAWD,MAAoB;AAC7E,UAAM;AAAA,MACJ,QAAAwJ;AAAA,MACA,gBAAAkC;AAAA,IACN,IAAQD,EAAe,SACb;AAAA,MACJ,eAAesG,IAAoB;AAAA,MACnC,aAAaC;AAAA,IACnB,IAAQhS,GACE;AAAA,MACJ,eAAeiS,IAAoB;AAAA,MACnC,aAAaC;AAAA,MACb,SAASC,IAAc;AAAA,MACvB,SAASC,IAAc;AAAA,IAC7B,IAAQnS,EAAU,aACR;AAAA,MACJ,WAAWoR;AAAA,IACjB,IAAQJ,GAAgBvF,GAAgBzL,GAAWuJ,CAAM;AACrD,IAAI6H,KAAiB,SAIjBW,KAAmBE,KAAmBzK,EAAoB4J,GAAeU,CAAiB,IACvFtK,EAAoBsK,GAAmBE,CAAiB,KAC3DvS,EAAYO,GAAWgS,CAAiB,IAEjCZ,IAAgBe,IACzB1S,EAAYO,GAAWmS,CAAW,IACzBf,IAAgBc,KACzBzS,EAAYO,GAAWkS,CAAW;AAAA,EAEtC,GAAG,CAACzS,CAAW,CAAC,GAGV2S,KAAgBpL,EAAY,CAACuD,GAAczI,MAAU;AACzD,UAAM;AAAA,MACJ,WAAAsC;AAAA,IACN,IAAQmH,EAAmB,SACjB;AAAA,MACJ,QAAAhC;AAAA,IACN,IAAQiC,EAAe;AACnB,QAAI,CAAC4E,EAAqB;AACxB;AAEF,UAAM1D,IAAgB9B,GAAuBL,GAAc6F,EAAqB,OAAO;AACvF,IAAAvN,EAAO6J,GAAe,yCAAyCnC,CAAY,GAAG;AAC9E,UAAMoC,IAAwBL,GAA6BlI,GAAWtC,CAAK;AAC3E,IAAAuO,EAAa;AAAA,MACX,cAAA9F;AAAA,MACA,gBAAgBmC,EAAc,sBAAqB;AAAA,MACnD,uBAAAC;AAAA,MACA,eAAepD;AAAA,IACrB,CAAK;AAAA,EACH,GAAG,CAAA,CAAE,GACC8I,KAAerL,EAAY,MAAM;AACrC,IAAAqJ,EAAa,IAAI;AAAA,EACnB,GAAG,CAAA,CAAE,GACC3Q,KAAkBsH,EAAY,CAAAhH,MAAa;AAC/C,UAAM;AAAA,MACJ,gBAAAyL;AAAA,IACN,IAAQD,EAAe,SACb3G,IAAQoM,GAAmBxF,GAAgBzL,CAAS;AAC1D,IAAI6E,KAAS,MACX4G,EAAe,OAAO5G,GAAO,CAAC,GAM9B,OAAO0L,EAAgC,QAAQvQ,EAAU,EAAE,GAC3DwL,EAAe,QAAQ,wBAAwB,IAC/C8E,EAAW;AAAA,EAEf,GAAG,CAACA,CAAW,CAAC,GACVvR,KAAUuT,GAAQ,OAAO;AAAA,IAC7B,eAAArT;AAAA,IACA,WAAAmF;AAAA,IACA,WAAAuJ;AAAA,IACA,aAAAzO;AAAA,IACA,cAAAC;AAAA,IACA,eAAAC;AAAA,IACA,SAAAC;AAAA,IACA,kBAAAC;AAAA,IACA,iBAAAgS;AAAA,IACA,4BAAA/R;AAAA,IACA,eAAAC;AAAA,IACA,sBAAAyE;AAAA,IACA,aAAAxE;AAAA,IACA,eAAA2S;AAAA,IACA,cAAAC;AAAA,IACA,iBAAA3S;AAAA,IACA,mBAAmB0Q,EAAqB;AAAA,EAC5C,IAAM,CAACnR,GAAe0O,GAAWvJ,GAAWlF,GAAaC,GAAcC,GAAeC,GAASC,GAAkBgS,IAAiB/R,IAA4BC,GAAeyE,GAAsBxE,GAAa2S,IAAeC,IAAc3S,EAAe,CAAC,GACrPS,KAAQ;AAAA,IACZ,SAAS;AAAA,IACT,eAAeiE,MAAc,eAAe,QAAQ;AAAA,IACpD,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,OAAO;AAAA,EACX;AACE,SAAOhE,GAAcrD,GAAkB,UAAU;AAAA,IAC/C,OAAOgC;AAAA,EACX,GAAKqB,GAAcvB,GAAM;AAAA,IACrB,GAAGC;AAAA,IACH,UAAAf;AAAA,IACA,WAAWC;AAAA,IACX,IAAIK;AAAA,IACJ,KAAK+R;AAAA,IACL,OAAO;AAAA,MACL,GAAGjQ;AAAA,MACH,GAAGvB;AAAA,IACT;AAAA;AAAA,IAEI,CAAC3B,EAAgB,KAAK,GAAG;AAAA,IACzB,CAACA,EAAgB,cAAc,GAAGmH;AAAA,IAClC,CAACnH,EAAgB,OAAO,GAAGoC;AAAA,EAC/B,CAAG,CAAC;AACJ;AACK,MAACkT,KAAajS,GAAW,CAACC,GAAOC,MAAQJ,GAAc8P,IAA4B;AAAA,EACtF,GAAG3P;AAAA,EACH,cAAcC;AAChB,CAAC,CAAC;AACF0P,GAA2B,cAAc;AACzCqC,GAAW,cAAc;AACzB,SAAStB,GAAmBxF,GAAgBzL,GAAW;AACrD,SAAOyL,EAAe,UAAU,CAAA+G,MAAiBA,MAAkBxS,KAAawS,EAAc,OAAOxS,EAAU,EAAE;AACnH;AACA,SAASgR,GAAgBvF,GAAgBzL,GAAWuJ,GAAQ;AAC1D,QAAMzB,IAAamJ,GAAmBxF,GAAgBzL,CAAS,GAEzDoI,IADcN,MAAe2D,EAAe,SAAS,IACxB,CAAC3D,IAAa,GAAGA,CAAU,IAAI,CAACA,GAAYA,IAAa,CAAC,GACvFiJ,IAAYxH,EAAOzB,CAAU;AACnC,SAAO;AAAA,IACL,GAAG9H,EAAU;AAAA,IACb,WAAA+Q;AAAA,IACA,cAAA3I;AAAA,EACJ;AACA;AAIA,SAASqK,GAAuC;AAAA,EAC9C,UAAAC;AAAA,EACA,UAAA5H;AAAA,EACA,eAAA6H;AAAA,EACA,mBAAAnI;AACF,GAAG;AACD,EAAAqB,GAAU,MAAM;AACd,QAAI6G,KAAYC,KAAiB,QAAQnI,KAAqB;AAC5D;AAEF,UAAMkC,IAAgB9B,GAAuBE,GAAUN,CAAiB;AACxE,QAAIkC,KAAiB;AACnB;AAEF,UAAMT,IAAY,CAAAnK,MAAS;AACzB,UAAI,CAAAA,EAAM;AAGV,gBAAQA,EAAM,KAAG;AAAA,UACf,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK,QACH;AACE,YAAAA,EAAM,eAAc,GACpB6Q,EAAc7Q,CAAK;AACnB;AAAA,UACF;AAAA,UACF,KAAK,MACH;AACE,YAAAA,EAAM,eAAc;AACpB,kBAAMzC,IAAUqN,EAAc,aAAazP,EAAgB,OAAO;AAClE,YAAA4F,EAAOxD,GAAS,kCAAkCA,CAAO,GAAG;AAC5D,kBAAM8L,IAAUlB,GAAgC5K,GAASmL,CAAiB,GACpE3F,IAAQsF,GAA4B9K,GAASyL,GAAUN,CAAiB;AAC9E,YAAA3H,EAAOgC,MAAU,MAAM,mCAAmCiG,CAAQ,GAAG;AACrE,kBAAM8H,IAAY9Q,EAAM,WAAW+C,IAAQ,IAAIA,IAAQ,IAAIsG,EAAQ,SAAS,IAAItG,IAAQ,IAAIsG,EAAQ,SAAStG,IAAQ,IAAI;AAEzH,YADmBsG,EAAQyH,CAAS,EACzB,MAAK;AAChB;AAAA,UACF;AAAA,QACV;AAAA,IACI;AACA,WAAAlG,EAAc,iBAAiB,WAAWT,CAAS,GAC5C,MAAM;AACX,MAAAS,EAAc,oBAAoB,WAAWT,CAAS;AAAA,IACxD;AAAA,EACF,GAAG,CAACzB,GAAmBkI,GAAU5H,GAAU6H,CAAa,CAAC;AAC3D;AAEA,SAASE,GAAkB;AAAA,EACzB,UAAA9U,IAAW;AAAA,EACX,WAAWC,IAAqB;AAAA,EAChC,UAAA0U,IAAW;AAAA,EACX,gBAAArO;AAAA,EACA,IAAIhG;AAAA,EACJ,QAAAyU;AAAA,EACA,SAAAC;AAAA,EACA,YAAAC;AAAA,EACA,SAAAC;AAAA,EACA,eAAAC;AAAA,EACA,aAAAC;AAAA,EACA,OAAOvU,IAAiB,CAAA;AAAA,EACxB,UAAAwU,IAAW;AAAA,EACX,SAASvU,IAAO;AAAA,EAChB,GAAGC;AACL,GAAG;AACD,MAAIuU,GAAuBC;AAC3B,QAAMC,IAAa1V,EAAO,IAAI,GAGxB2V,IAAe3V,EAAO;AAAA,IAC1B,SAAAkV;AAAA,IACA,YAAAC;AAAA,IACA,eAAAE;AAAA,IACA,aAAAC;AAAA,EACJ,CAAG;AACD,EAAAtH,GAAU,MAAM;AACd,IAAA2H,EAAa,QAAQ,UAAUT,GAC/BS,EAAa,QAAQ,aAAaR,GAClCQ,EAAa,QAAQ,gBAAgBN,GACrCM,EAAa,QAAQ,cAAcL;AAAA,EACrC,CAAC;AACD,QAAMM,IAAoBzU,GAAWjC,EAAiB;AACtD,MAAI0W,MAAsB;AACxB,UAAM,MAAM,6EAA6E;AAE3F,QAAM;AAAA,IACJ,WAAArP;AAAA,IACA,SAAA/E;AAAA,IACA,sBAAsBqU;AAAA,IACtB,eAAAtB;AAAA,IACA,cAAAC;AAAA,IACA,mBAAA7H;AAAA,EACJ,IAAMiJ,GACEvP,IAAiBzG,GAAYY,CAAW,GACxC,CAACwC,GAAO8S,CAAQ,IAAI5M,GAAS,UAAU,GACvC,CAAC6M,IAAWC,CAAY,IAAI9M,GAAS,EAAK,GAC1C,CAAC4L,GAAemB,CAAgB,IAAI/M,GAAS,IAAI,GACjDwE,KAAqB1N,EAAO;AAAA,IAChC,OAAAgD;AAAA,EACJ,CAAG;AACD,EAAA1D,GAA0B,MAAM;AAC9B,IAAAoO,GAAmB,QAAQ,QAAQ1K;AAAA,EACrC,CAAC,GACDgL,GAAU,MAAM;AACd,QAAI6G;AACF,MAAAoB,EAAiB,IAAI;AAAA,SAChB;AACL,YAAMnB,KAAgBe,EAAoCxP,CAAc;AACxE,MAAA4P,EAAiB,MAAMnB,EAAa;AAAA,IACtC;AAAA,EACF,GAAG,CAACD,GAAUxO,GAAgBwP,CAAmC,CAAC;AAIlE,QAAMK,MAAwBV,IAAwFhP,GAAe,YAAY,QAAQgP,MAA0B,SAASA,IAAwB,IAC9MW,MAAsBV,IAAuFjP,GAAe,UAAU,QAAQiP,MAAyB,SAASA,IAAuB;AAC7M,SAAAzH,GAAU,MAAM;AACd,QAAI6G,KAAYC,KAAiB;AAC/B;AAEF,UAAMxO,KAAUoP,EAAW;AAC3B,IAAA1Q,EAAOsB,IAAS,0BAA0B;AAC1C,QAAI8P,KAAU;AAoDd,WAAOhQ,GAAqBC,GAAgBC,IAASC,GAAW;AAAA,MAC9D,QAAQ2P;AAAA,MACR,MAAMC;AAAA,IACZ,GAtDkC,CAACrN,GAAQC,GAAU9E,MAAU;AACzD,UAAI,CAAC8E,GAAU;AACb,QAAA+M,EAAS,UAAU;AACnB;AAAA,MACF;AACA,cAAQhN,GAAM;AAAA,QACZ,KAAK,QACH;AACE,UAAAgN,EAAS,MAAM,GACfM,KAAU,IACVpR,EAAOf,GAAO,gDAAgD,GAC9DsQ,EAAclO,GAAgBpC,CAAK;AACnC,gBAAM;AAAA,YACJ,YAAAkR;AAAA,YACA,eAAAE;AAAA,UACd,IAAgBM,EAAa;AACjB,UAAwDR,IAAW,EAAI,GACTE,IAAa;AAC3E;AAAA,QACF;AAAA,QACF,KAAK,QACH;AACE,gBAAM;AAAA,YACJ,OAAArS;AAAA,UACd,IAAgB0K,GAAmB;AACvB,UAAA0I,KAAU,IACNpT,MAAU,UACZ8S,EAAS,OAAO,GAElB9Q,EAAOf,GAAO,gDAAgD,GAC9D6Q,EAAc7Q,CAAK;AACnB;AAAA,QACF;AAAA,QACF,KAAK,MACH;AACE,UAAA6R,EAAS,OAAO,GAChBtB,EAAY;AACZ,gBAAM;AAAA,YACJ,SAAAU;AAAA,YACA,YAAAC;AAAA,YACA,aAAAG;AAAA,UACd,IAAgBK,EAAa;AACjB,UAAwDR,IAAW,EAAK,GACdG,IAAW,GAChEc,MAC+ClB,IAAO;AAE3D;AAAA,QACF;AAAA,MACV;AAAA,IACI,CAIwB;AAAA,EAC1B,GAAG,CAACgB,IAAsB3P,GAAWsO,GAAUsB,IAAoBN,GAAqCxP,GAAgByO,GAAeP,GAAeC,CAAY,CAAC,GACnKI,GAAuC;AAAA,IACrC,UAAAC;AAAA,IACA,UAAUxO;AAAA,IACV,eAAAyO;AAAA,IACA,mBAAAnI;AAAA,EACJ,CAAG,GAKMpK,GAAcvB,GAAM;AAAA,IACzB,GAAGC;AAAA,IACH,UAAAf;AAAA,IACA,WAAWC;AAAA,IACX,IAAIK;AAAA,IACJ,QAAQ,MAAM;AACZ,MAAAwV,EAAa,EAAK,GAC8Bf,IAAM;AAAA,IACxD;AAAA,IACA,SAAS,MAAM;AACb,MAAAe,EAAa,EAAI,GACiCZ,IAAO;AAAA,IAC3D;AAAA,IACA,KAAKM;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,MACL,GApBU;AAAA,QACZ,aAAa;AAAA,QACb,YAAY;AAAA,MAChB;AAAA,MAkBM,GAAG3U;AAAA,IACT;AAAA,IACI,UAAAwU;AAAA;AAAA,IAEA,CAACnW,EAAgB,cAAc,GAAGmH;AAAA,IAClC,CAACnH,EAAgB,OAAO,GAAGoC;AAAA,IAC3B,CAACpC,EAAgB,YAAY,GAAG;AAAA,IAChC,CAACA,EAAgB,kBAAkB,GAAG4D,MAAU,SAAS,YAAY+S,KAAY,aAAa;AAAA,IAC9F,CAAC3W,EAAgB,mBAAmB,GAAG,CAACyV;AAAA,IACxC,CAACzV,EAAgB,cAAc,GAAGiH;AAAA,IAClC,CAACjH,EAAgB,iBAAiB,GAAG4D;AAAA,EACzC,CAAG;AACH;AACAgS,GAAkB,cAAc;","x_google_ignoreList":[0]}